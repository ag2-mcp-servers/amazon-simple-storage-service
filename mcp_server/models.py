# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T13:30:29+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, SecretStr, constr


class AbortDate(RootModel[datetime]):
    root: datetime


class AbortMultipartUploadOutput(BaseModel):
    pass


class AbortMultipartUploadRequest(BaseModel):
    pass


class AbortRuleId(RootModel[str]):
    root: str


class AcceptRanges(RootModel[str]):
    root: str


class AccessPointArn(RootModel[str]):
    root: str


class AccountId(RootModel[str]):
    root: str


class AllowQuotedRecordDelimiter(RootModel[bool]):
    root: bool


class AllowedHeader(RootModel[str]):
    root: str


class AllowedHeaders(RootModel[List[AllowedHeader]]):
    root: List[AllowedHeader]


class AllowedMethod(RootModel[str]):
    root: str


class AllowedMethods(RootModel[List[AllowedMethod]]):
    root: List[AllowedMethod]


class AllowedOrigin(RootModel[str]):
    root: str


class AllowedOrigins(RootModel[List[AllowedOrigin]]):
    root: List[AllowedOrigin]


class AnalyticsId(RootModel[str]):
    root: str


class AnalyticsS3ExportFileFormat(Enum):
    CSV = 'CSV'


class ArchiveStatus(Enum):
    ARCHIVE_ACCESS = 'ARCHIVE_ACCESS'
    DEEP_ARCHIVE_ACCESS = 'DEEP_ARCHIVE_ACCESS'


class Body(RootModel[str]):
    root: str


class BucketAccelerateStatus(Enum):
    Enabled = 'Enabled'
    Suspended = 'Suspended'


class BucketAlreadyExists(RootModel[Any]):
    root: Any


class BucketAlreadyOwnedByYou(RootModel[Any]):
    root: Any


class BucketCannedACL(Enum):
    private = 'private'
    public_read = 'public-read'
    public_read_write = 'public-read-write'
    authenticated_read = 'authenticated-read'


class BucketKeyEnabled(RootModel[bool]):
    root: bool


class BucketLocationConstraint(Enum):
    af_south_1 = 'af-south-1'
    ap_east_1 = 'ap-east-1'
    ap_northeast_1 = 'ap-northeast-1'
    ap_northeast_2 = 'ap-northeast-2'
    ap_northeast_3 = 'ap-northeast-3'
    ap_south_1 = 'ap-south-1'
    ap_southeast_1 = 'ap-southeast-1'
    ap_southeast_2 = 'ap-southeast-2'
    ap_southeast_3 = 'ap-southeast-3'
    ca_central_1 = 'ca-central-1'
    cn_north_1 = 'cn-north-1'
    cn_northwest_1 = 'cn-northwest-1'
    EU = 'EU'
    eu_central_1 = 'eu-central-1'
    eu_north_1 = 'eu-north-1'
    eu_south_1 = 'eu-south-1'
    eu_west_1 = 'eu-west-1'
    eu_west_2 = 'eu-west-2'
    eu_west_3 = 'eu-west-3'
    me_south_1 = 'me-south-1'
    sa_east_1 = 'sa-east-1'
    us_east_2 = 'us-east-2'
    us_gov_east_1 = 'us-gov-east-1'
    us_gov_west_1 = 'us-gov-west-1'
    us_west_1 = 'us-west-1'
    us_west_2 = 'us-west-2'


class BucketLogsPermission(Enum):
    FULL_CONTROL = 'FULL_CONTROL'
    READ = 'READ'
    WRITE = 'WRITE'


class BucketName(RootModel[str]):
    root: str


class BucketVersioningStatus(Enum):
    Enabled = 'Enabled'
    Suspended = 'Suspended'


class BypassGovernanceRetention(RootModel[bool]):
    root: bool


class BytesProcessed(RootModel[int]):
    root: int


class BytesReturned(RootModel[int]):
    root: int


class BytesScanned(RootModel[int]):
    root: int


class CacheControl(RootModel[str]):
    root: str


class ChecksumAlgorithm(Enum):
    CRC32 = 'CRC32'
    CRC32C = 'CRC32C'
    SHA1 = 'SHA1'
    SHA256 = 'SHA256'


class ChecksumAlgorithmList(RootModel[List[ChecksumAlgorithm]]):
    root: List[ChecksumAlgorithm]


class ChecksumCRC32(RootModel[str]):
    root: str


class ChecksumCRC32C(RootModel[str]):
    root: str


class ChecksumMode(Enum):
    ENABLED = 'ENABLED'


class ChecksumSHA1(RootModel[str]):
    root: str


class ChecksumSHA256(RootModel[str]):
    root: str


class CloudFunction(RootModel[str]):
    root: str


class CloudFunctionInvocationRole(RootModel[str]):
    root: str


class Code(RootModel[str]):
    root: str


class Comments(RootModel[str]):
    root: str


class CompressionType(Enum):
    NONE = 'NONE'
    GZIP = 'GZIP'
    BZIP2 = 'BZIP2'


class ConfirmRemoveSelfBucketAccess(RootModel[bool]):
    root: bool


class ContentDisposition(RootModel[str]):
    root: str


class ContentEncoding(RootModel[str]):
    root: str


class ContentLanguage(RootModel[str]):
    root: str


class ContentLength(RootModel[int]):
    root: int


class ContentMD5(RootModel[str]):
    root: str


class ContentRange(RootModel[str]):
    root: str


class ContentType(RootModel[str]):
    root: str


class ContinuationEvent(BaseModel):
    pass


class CopySource(RootModel[constr(pattern=r'\/.+\/.+')]):
    root: constr(pattern=r'\/.+\/.+')


class CopySourceIfMatch(RootModel[str]):
    root: str


class CopySourceIfModifiedSince(RootModel[datetime]):
    root: datetime


class CopySourceIfNoneMatch(RootModel[str]):
    root: str


class CopySourceIfUnmodifiedSince(RootModel[datetime]):
    root: datetime


class CopySourceRange(RootModel[str]):
    root: str


class CopySourceSSECustomerAlgorithm(RootModel[str]):
    root: str


class CopySourceSSECustomerKey(RootModel[SecretStr]):
    root: SecretStr


class CopySourceSSECustomerKeyMD5(RootModel[str]):
    root: str


class CopySourceVersionId(RootModel[str]):
    root: str


class CreateBucketConfiguration(BaseModel):
    LocationConstraint: Optional[BucketLocationConstraint] = None


class CreateBucketOutput(BaseModel):
    pass


class CreateBucketRequest(BaseModel):
    CreateBucketConfiguration_1: Optional[CreateBucketConfiguration] = Field(
        None, alias='CreateBucketConfiguration'
    )


class CreationDate(RootModel[datetime]):
    root: datetime


class Date(RootModel[datetime]):
    root: datetime


class Days(RootModel[int]):
    root: int


class DaysAfterInitiation(RootModel[int]):
    root: int


class DeleteBucketAnalyticsConfigurationRequest(BaseModel):
    pass


class DeleteBucketCorsRequest(BaseModel):
    pass


class DeleteBucketEncryptionRequest(BaseModel):
    pass


class DeleteBucketIntelligentTieringConfigurationRequest(BaseModel):
    pass


class DeleteBucketInventoryConfigurationRequest(BaseModel):
    pass


class DeleteBucketLifecycleRequest(BaseModel):
    pass


class DeleteBucketMetricsConfigurationRequest(BaseModel):
    pass


class DeleteBucketOwnershipControlsRequest(BaseModel):
    pass


class DeleteBucketPolicyRequest(BaseModel):
    pass


class DeleteBucketReplicationRequest(BaseModel):
    pass


class DeleteBucketRequest(BaseModel):
    pass


class DeleteBucketTaggingRequest(BaseModel):
    pass


class DeleteBucketWebsiteRequest(BaseModel):
    pass


class DeleteMarker(RootModel[bool]):
    root: bool


class DeleteMarkerReplicationStatus(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'


class DeleteMarkerVersionId(RootModel[str]):
    root: str


class DeleteObjectOutput(BaseModel):
    pass


class DeleteObjectRequest(BaseModel):
    pass


class DeleteObjectTaggingOutput(BaseModel):
    pass


class DeleteObjectTaggingRequest(BaseModel):
    pass


class DeletePublicAccessBlockRequest(BaseModel):
    pass


class Delimiter(RootModel[str]):
    root: str


class Description(RootModel[str]):
    root: str


class DisplayName(RootModel[str]):
    root: str


class ETag(RootModel[str]):
    root: str


class EmailAddress(RootModel[str]):
    root: str


class EnableRequestProgress(RootModel[bool]):
    root: bool


class EncodingType(Enum):
    url = 'url'


class End(RootModel[int]):
    root: int


class EndEvent(BaseModel):
    pass


class ErrorCode(RootModel[str]):
    root: str


class ErrorMessage(RootModel[str]):
    root: str


class Event(Enum):
    s3_ReducedRedundancyLostObject = 's3:ReducedRedundancyLostObject'
    s3_ObjectCreated__ = 's3:ObjectCreated:*'
    s3_ObjectCreated_Put = 's3:ObjectCreated:Put'
    s3_ObjectCreated_Post = 's3:ObjectCreated:Post'
    s3_ObjectCreated_Copy = 's3:ObjectCreated:Copy'
    s3_ObjectCreated_CompleteMultipartUpload = (
        's3:ObjectCreated:CompleteMultipartUpload'
    )
    s3_ObjectRemoved__ = 's3:ObjectRemoved:*'
    s3_ObjectRemoved_Delete = 's3:ObjectRemoved:Delete'
    s3_ObjectRemoved_DeleteMarkerCreated = 's3:ObjectRemoved:DeleteMarkerCreated'
    s3_ObjectRestore__ = 's3:ObjectRestore:*'
    s3_ObjectRestore_Post = 's3:ObjectRestore:Post'
    s3_ObjectRestore_Completed = 's3:ObjectRestore:Completed'
    s3_Replication__ = 's3:Replication:*'
    s3_Replication_OperationFailedReplication = (
        's3:Replication:OperationFailedReplication'
    )
    s3_Replication_OperationNotTracked = 's3:Replication:OperationNotTracked'
    s3_Replication_OperationMissedThreshold = 's3:Replication:OperationMissedThreshold'
    s3_Replication_OperationReplicatedAfterThreshold = (
        's3:Replication:OperationReplicatedAfterThreshold'
    )
    s3_ObjectRestore_Delete = 's3:ObjectRestore:Delete'
    s3_LifecycleTransition = 's3:LifecycleTransition'
    s3_IntelligentTiering = 's3:IntelligentTiering'
    s3_ObjectAcl_Put = 's3:ObjectAcl:Put'
    s3_LifecycleExpiration__ = 's3:LifecycleExpiration:*'
    s3_LifecycleExpiration_Delete = 's3:LifecycleExpiration:Delete'
    s3_LifecycleExpiration_DeleteMarkerCreated = (
        's3:LifecycleExpiration:DeleteMarkerCreated'
    )
    s3_ObjectTagging__ = 's3:ObjectTagging:*'
    s3_ObjectTagging_Put = 's3:ObjectTagging:Put'
    s3_ObjectTagging_Delete = 's3:ObjectTagging:Delete'


class EventBridgeConfiguration(BaseModel):
    pass


class EventList(RootModel[List[Event]]):
    root: List[Event]


class ExistingObjectReplicationStatus(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'


class Expiration(RootModel[str]):
    root: str


class ExpirationStatus(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'


class ExpiredObjectDeleteMarker(RootModel[bool]):
    root: bool


class Expires(RootModel[datetime]):
    root: datetime


class ExposeHeader(RootModel[str]):
    root: str


class ExposeHeaders(RootModel[List[ExposeHeader]]):
    root: List[ExposeHeader]


class Expression(RootModel[str]):
    root: str


class ExpressionType(Enum):
    SQL = 'SQL'


class FetchOwner(RootModel[bool]):
    root: bool


class FieldDelimiter(RootModel[str]):
    root: str


class FileHeaderInfo(Enum):
    USE = 'USE'
    IGNORE = 'IGNORE'
    NONE = 'NONE'


class FilterRuleName(Enum):
    prefix = 'prefix'
    suffix = 'suffix'


class FilterRuleValue(RootModel[str]):
    root: str


class GetBucketAccelerateConfigurationOutput(BaseModel):
    Status: Optional[BucketAccelerateStatus] = None


class GetBucketAccelerateConfigurationRequest(BaseModel):
    pass


class GetBucketAclRequest(BaseModel):
    pass


class GetBucketAnalyticsConfigurationRequest(BaseModel):
    pass


class GetBucketCorsRequest(BaseModel):
    pass


class GetBucketEncryptionRequest(BaseModel):
    pass


class GetBucketIntelligentTieringConfigurationRequest(BaseModel):
    pass


class GetBucketInventoryConfigurationRequest(BaseModel):
    pass


class GetBucketLifecycleConfigurationRequest(BaseModel):
    pass


class GetBucketLifecycleRequest(BaseModel):
    pass


class GetBucketLocationOutput(BaseModel):
    LocationConstraint: Optional[BucketLocationConstraint] = None


class GetBucketLocationRequest(BaseModel):
    pass


class GetBucketLoggingRequest(BaseModel):
    pass


class GetBucketMetricsConfigurationRequest(BaseModel):
    pass


class GetBucketNotificationConfigurationRequest(BaseModel):
    pass


class GetBucketOwnershipControlsRequest(BaseModel):
    pass


class GetBucketPolicyRequest(BaseModel):
    pass


class GetBucketPolicyStatusRequest(BaseModel):
    pass


class GetBucketReplicationRequest(BaseModel):
    pass


class GetBucketRequestPaymentRequest(BaseModel):
    pass


class GetBucketTaggingRequest(BaseModel):
    pass


class GetBucketVersioningRequest(BaseModel):
    pass


class GetBucketWebsiteRequest(BaseModel):
    pass


class GetObjectAclRequest(BaseModel):
    pass


class GetObjectAttributesRequest(BaseModel):
    pass


class GetObjectLegalHoldRequest(BaseModel):
    pass


class GetObjectLockConfigurationRequest(BaseModel):
    pass


class GetObjectRequest(BaseModel):
    pass


class GetObjectResponseStatusCode(RootModel[int]):
    root: int


class GetObjectRetentionRequest(BaseModel):
    pass


class GetObjectTaggingRequest(BaseModel):
    pass


class GetObjectTorrentOutput(BaseModel):
    Body_1: Optional[Body] = Field(None, alias='Body')


class GetObjectTorrentRequest(BaseModel):
    pass


class GetPublicAccessBlockRequest(BaseModel):
    pass


class GrantFullControl(RootModel[str]):
    root: str


class GrantRead(RootModel[str]):
    root: str


class GrantReadACP(RootModel[str]):
    root: str


class GrantWrite(RootModel[str]):
    root: str


class GrantWriteACP(RootModel[str]):
    root: str


class HeadBucketRequest(BaseModel):
    pass


class HeadObjectRequest(BaseModel):
    pass


class HostName(RootModel[str]):
    root: str


class HttpErrorCodeReturnedEquals(RootModel[str]):
    root: str


class HttpRedirectCode(RootModel[str]):
    root: str


class ID(RootModel[str]):
    root: str


class IfMatch(RootModel[str]):
    root: str


class IfModifiedSince(RootModel[datetime]):
    root: datetime


class IfNoneMatch(RootModel[str]):
    root: str


class IfUnmodifiedSince(RootModel[datetime]):
    root: datetime


class Initiated(RootModel[datetime]):
    root: datetime


class Initiator(BaseModel):
    DisplayName_1: Optional[DisplayName] = Field(None, alias='DisplayName')
    ID_1: Optional[ID] = Field(None, alias='ID')


class IntelligentTieringAccessTier(Enum):
    ARCHIVE_ACCESS = 'ARCHIVE_ACCESS'
    DEEP_ARCHIVE_ACCESS = 'DEEP_ARCHIVE_ACCESS'


class IntelligentTieringDays(RootModel[int]):
    root: int


class IntelligentTieringId(RootModel[str]):
    root: str


class IntelligentTieringStatus(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'


class InvalidObjectState(RootModel[Any]):
    root: Any


class InventoryFormat(Enum):
    CSV = 'CSV'
    ORC = 'ORC'
    Parquet = 'Parquet'


class InventoryFrequency(Enum):
    Daily = 'Daily'
    Weekly = 'Weekly'


class InventoryId(RootModel[str]):
    root: str


class InventoryIncludedObjectVersions(Enum):
    All = 'All'
    Current = 'Current'


class InventoryOptionalField(Enum):
    Size = 'Size'
    LastModifiedDate = 'LastModifiedDate'
    StorageClass = 'StorageClass'
    ETag = 'ETag'
    IsMultipartUploaded = 'IsMultipartUploaded'
    ReplicationStatus = 'ReplicationStatus'
    EncryptionStatus = 'EncryptionStatus'
    ObjectLockRetainUntilDate = 'ObjectLockRetainUntilDate'
    ObjectLockMode = 'ObjectLockMode'
    ObjectLockLegalHoldStatus = 'ObjectLockLegalHoldStatus'
    IntelligentTieringAccessTier = 'IntelligentTieringAccessTier'
    BucketKeyStatus = 'BucketKeyStatus'
    ChecksumAlgorithm = 'ChecksumAlgorithm'


class InventoryOptionalFields(RootModel[List[InventoryOptionalField]]):
    root: List[InventoryOptionalField]


class InventorySchedule(BaseModel):
    Frequency: InventoryFrequency


class IsEnabled(RootModel[bool]):
    root: bool


class IsLatest(RootModel[bool]):
    root: bool


class IsPublic(RootModel[bool]):
    root: bool


class IsTruncated(RootModel[bool]):
    root: bool


class JSONType(Enum):
    DOCUMENT = 'DOCUMENT'
    LINES = 'LINES'


class KMSContext(RootModel[str]):
    root: str


class KeyCount(RootModel[int]):
    root: int


class KeyMarker(RootModel[str]):
    root: str


class KeyPrefixEquals(RootModel[str]):
    root: str


class LambdaFunctionArn(RootModel[str]):
    root: str


class LastModified(RootModel[datetime]):
    root: datetime


class LifecycleExpiration(BaseModel):
    Date_1: Optional[Date] = Field(None, alias='Date')
    Days_1: Optional[Days] = Field(None, alias='Days')
    ExpiredObjectDeleteMarker_1: Optional[ExpiredObjectDeleteMarker] = Field(
        None, alias='ExpiredObjectDeleteMarker'
    )


class ListBucketAnalyticsConfigurationsRequest(BaseModel):
    pass


class ListBucketIntelligentTieringConfigurationsRequest(BaseModel):
    pass


class ListBucketInventoryConfigurationsRequest(BaseModel):
    pass


class ListBucketMetricsConfigurationsRequest(BaseModel):
    pass


class ListMultipartUploadsRequest(BaseModel):
    pass


class ListObjectVersionsRequest(BaseModel):
    pass


class ListObjectsRequest(BaseModel):
    pass


class ListObjectsV2Request(BaseModel):
    pass


class ListPartsRequest(BaseModel):
    pass


class Location(RootModel[str]):
    root: str


class LocationPrefix(RootModel[str]):
    root: str


class MFA(RootModel[str]):
    root: str


class MFADelete(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'


class MFADeleteStatus(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'


class Marker(RootModel[str]):
    root: str


class MaxAgeSeconds(RootModel[int]):
    root: int


class MaxKeys(RootModel[int]):
    root: int


class MaxParts(RootModel[int]):
    root: int


class MaxUploads(RootModel[int]):
    root: int


class Message(RootModel[str]):
    root: str


class MetadataDirective(Enum):
    COPY = 'COPY'
    REPLACE = 'REPLACE'


class MetadataKey(RootModel[str]):
    root: str


class MetadataValue(RootModel[str]):
    root: str


class MetricsId(RootModel[str]):
    root: str


class MetricsStatus(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'


class Minutes(RootModel[int]):
    root: int


class MissingMeta(RootModel[int]):
    root: int


class MultipartUploadId(RootModel[str]):
    root: str


class NextKeyMarker(RootModel[str]):
    root: str


class NextMarker(RootModel[str]):
    root: str


class NextPartNumberMarker(RootModel[int]):
    root: int


class NextToken(RootModel[str]):
    root: str


class NextUploadIdMarker(RootModel[str]):
    root: str


class NextVersionIdMarker(RootModel[str]):
    root: str


class NoSuchBucket(RootModel[Any]):
    root: Any


class NoSuchKey(RootModel[Any]):
    root: Any


class NoSuchUpload(RootModel[Any]):
    root: Any


class NotificationId(RootModel[str]):
    root: str = Field(
        ...,
        description="An optional unique identifier for configurations in a notification configuration. If you don't provide one, Amazon S3 will assign an ID.",
    )


class ObjectAlreadyInActiveTierError(RootModel[Any]):
    root: Any


class ObjectAttributes(Enum):
    ETag = 'ETag'
    Checksum = 'Checksum'
    ObjectParts = 'ObjectParts'
    StorageClass = 'StorageClass'
    ObjectSize = 'ObjectSize'


class ObjectAttributesList(RootModel[List[ObjectAttributes]]):
    root: List[ObjectAttributes]


class ObjectCannedACL(Enum):
    private = 'private'
    public_read = 'public-read'
    public_read_write = 'public-read-write'
    authenticated_read = 'authenticated-read'
    aws_exec_read = 'aws-exec-read'
    bucket_owner_read = 'bucket-owner-read'
    bucket_owner_full_control = 'bucket-owner-full-control'


class ObjectKey(RootModel[constr(min_length=1)]):
    root: constr(min_length=1)


class ObjectLockEnabled(Enum):
    Enabled = 'Enabled'


class ObjectLockEnabledForBucket(RootModel[bool]):
    root: bool


class ObjectLockLegalHoldStatus(Enum):
    ON = 'ON'
    OFF = 'OFF'


class ObjectLockMode(Enum):
    GOVERNANCE = 'GOVERNANCE'
    COMPLIANCE = 'COMPLIANCE'


class ObjectLockRetainUntilDate(RootModel[datetime]):
    root: datetime


class ObjectLockRetentionMode(Enum):
    GOVERNANCE = 'GOVERNANCE'
    COMPLIANCE = 'COMPLIANCE'


class ObjectLockToken(RootModel[str]):
    root: str


class ObjectNotInActiveTierError(RootModel[Any]):
    root: Any


class ObjectOwnership(Enum):
    BucketOwnerPreferred = 'BucketOwnerPreferred'
    ObjectWriter = 'ObjectWriter'
    BucketOwnerEnforced = 'BucketOwnerEnforced'


class ObjectSize(RootModel[int]):
    root: int


class ObjectSizeGreaterThanBytes(RootModel[int]):
    root: int


class ObjectSizeLessThanBytes(RootModel[int]):
    root: int


class ObjectStorageClass(Enum):
    STANDARD = 'STANDARD'
    REDUCED_REDUNDANCY = 'REDUCED_REDUNDANCY'
    GLACIER = 'GLACIER'
    STANDARD_IA = 'STANDARD_IA'
    ONEZONE_IA = 'ONEZONE_IA'
    INTELLIGENT_TIERING = 'INTELLIGENT_TIERING'
    DEEP_ARCHIVE = 'DEEP_ARCHIVE'
    OUTPOSTS = 'OUTPOSTS'
    GLACIER_IR = 'GLACIER_IR'
    SNOW = 'SNOW'


class ObjectVersionId(RootModel[str]):
    root: str


class ObjectVersionStorageClass(Enum):
    STANDARD = 'STANDARD'


class Owner(BaseModel):
    DisplayName_1: Optional[DisplayName] = Field(None, alias='DisplayName')
    ID_1: Optional[ID] = Field(None, alias='ID')


class OwnerOverride(Enum):
    Destination = 'Destination'


class OwnershipControlsRule(BaseModel):
    ObjectOwnership_1: ObjectOwnership = Field(..., alias='ObjectOwnership')


class OwnershipControlsRules(RootModel[List[OwnershipControlsRule]]):
    root: List[OwnershipControlsRule]


class ParquetInput(BaseModel):
    pass


class PartNumber(RootModel[int]):
    root: int


class PartNumberMarker(RootModel[int]):
    root: int


class PartsCount(RootModel[int]):
    root: int


class Payer(Enum):
    Requester = 'Requester'
    BucketOwner = 'BucketOwner'


class Permission(Enum):
    FULL_CONTROL = 'FULL_CONTROL'
    WRITE = 'WRITE'
    WRITE_ACP = 'WRITE_ACP'
    READ = 'READ'
    READ_ACP = 'READ_ACP'


class Policy(RootModel[str]):
    root: str


class PolicyStatus(BaseModel):
    IsPublic_1: Optional[IsPublic] = Field(None, alias='IsPublic')


class Prefix(RootModel[str]):
    root: str


class Priority(RootModel[int]):
    root: int


class Progress(BaseModel):
    BytesProcessed_1: Optional[BytesProcessed] = Field(None, alias='BytesProcessed')
    BytesReturned_1: Optional[BytesReturned] = Field(None, alias='BytesReturned')
    BytesScanned_1: Optional[BytesScanned] = Field(None, alias='BytesScanned')


class ProgressEvent(BaseModel):
    Details: Optional[Progress] = None


class Protocol(Enum):
    http = 'http'
    https = 'https'


class PutBucketPolicyRequest(BaseModel):
    Policy_1: Policy = Field(..., alias='Policy')


class PutObjectAclOutput(BaseModel):
    pass


class PutObjectLegalHoldOutput(BaseModel):
    pass


class PutObjectLockConfigurationOutput(BaseModel):
    pass


class PutObjectOutput(BaseModel):
    pass


class PutObjectRetentionOutput(BaseModel):
    pass


class PutObjectTaggingOutput(BaseModel):
    pass


class QueueArn(RootModel[str]):
    root: str


class QueueConfigurationDeprecated(BaseModel):
    Event_1: Optional[Event] = Field(None, alias='Event')
    Events: Optional[EventList] = None
    Id: Optional[NotificationId] = None
    Queue: Optional[QueueArn] = None


class Quiet(RootModel[bool]):
    root: bool


class QuoteCharacter(RootModel[str]):
    root: str


class QuoteEscapeCharacter(RootModel[str]):
    root: str


class QuoteFields(Enum):
    ALWAYS = 'ALWAYS'
    ASNEEDED = 'ASNEEDED'


class Range(RootModel[str]):
    root: str


class RecordDelimiter(RootModel[str]):
    root: str


class RecordsEvent(BaseModel):
    Payload: Optional[Body] = None


class RedirectAllRequestsTo(BaseModel):
    HostName_1: HostName = Field(..., alias='HostName')
    Protocol_1: Optional[Protocol] = Field(None, alias='Protocol')


class ReplaceKeyPrefixWith(RootModel[str]):
    root: str


class ReplaceKeyWith(RootModel[str]):
    root: str


class ReplicaKmsKeyID(RootModel[str]):
    root: str


class ReplicaModificationsStatus(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'


class ReplicationRuleStatus(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'


class ReplicationStatus(Enum):
    COMPLETE = 'COMPLETE'
    PENDING = 'PENDING'
    FAILED = 'FAILED'
    REPLICA = 'REPLICA'


class ReplicationTimeStatus(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'


class ReplicationTimeValue(BaseModel):
    Minutes_1: Optional[Minutes] = Field(None, alias='Minutes')


class RequestCharged(Enum):
    requester = 'requester'


class RequestPayer(Enum):
    requester = 'requester'


class RequestPaymentConfiguration(BaseModel):
    Payer_1: Payer = Field(..., alias='Payer')


class RequestProgress(BaseModel):
    Enabled: Optional[EnableRequestProgress] = None


class RequestRoute(RootModel[str]):
    root: str


class RequestToken(RootModel[str]):
    root: str


class ResponseCacheControl(RootModel[str]):
    root: str


class ResponseContentDisposition(RootModel[str]):
    root: str


class ResponseContentEncoding(RootModel[str]):
    root: str


class ResponseContentLanguage(RootModel[str]):
    root: str


class ResponseContentType(RootModel[str]):
    root: str


class ResponseExpires(RootModel[datetime]):
    root: datetime


class Restore(RootModel[str]):
    root: str


class RestoreObjectOutput(BaseModel):
    pass


class RestoreOutputPath(RootModel[str]):
    root: str


class RestoreRequestType(Enum):
    SELECT = 'SELECT'


class Role(RootModel[str]):
    root: str


class SSECustomerAlgorithm(RootModel[str]):
    root: str


class SSECustomerKey(RootModel[SecretStr]):
    root: SecretStr


class SSECustomerKeyMD5(RootModel[str]):
    root: str


class SSEKMSEncryptionContext(RootModel[SecretStr]):
    root: SecretStr


class SSEKMSKeyId(RootModel[SecretStr]):
    root: SecretStr


class SSES3(BaseModel):
    pass


class ServerSideEncryption(Enum):
    AES256 = 'AES256'
    aws_kms = 'aws:kms'


class ServerSideEncryptionByDefault(BaseModel):
    KMSMasterKeyID: Optional[SSEKMSKeyId] = None
    SSEAlgorithm: ServerSideEncryption


class ServerSideEncryptionRule(BaseModel):
    ApplyServerSideEncryptionByDefault: Optional[ServerSideEncryptionByDefault] = None
    BucketKeyEnabled_1: Optional[BucketKeyEnabled] = Field(
        None, alias='BucketKeyEnabled'
    )


class ServerSideEncryptionRules(RootModel[List[ServerSideEncryptionRule]]):
    root: List[ServerSideEncryptionRule]


class Setting(RootModel[bool]):
    root: bool


class Size(RootModel[int]):
    root: int


class SkipValidation(RootModel[bool]):
    root: bool


class SseKmsEncryptedObjectsStatus(Enum):
    Enabled = 'Enabled'
    Disabled = 'Disabled'


class Start(RootModel[int]):
    root: int


class StartAfter(RootModel[str]):
    root: str


class Stats(BaseModel):
    BytesProcessed_1: Optional[BytesProcessed] = Field(None, alias='BytesProcessed')
    BytesReturned_1: Optional[BytesReturned] = Field(None, alias='BytesReturned')
    BytesScanned_1: Optional[BytesScanned] = Field(None, alias='BytesScanned')


class StatsEvent(BaseModel):
    Details: Optional[Stats] = None


class StorageClass(Enum):
    STANDARD = 'STANDARD'
    REDUCED_REDUNDANCY = 'REDUCED_REDUNDANCY'
    STANDARD_IA = 'STANDARD_IA'
    ONEZONE_IA = 'ONEZONE_IA'
    INTELLIGENT_TIERING = 'INTELLIGENT_TIERING'
    GLACIER = 'GLACIER'
    DEEP_ARCHIVE = 'DEEP_ARCHIVE'
    OUTPOSTS = 'OUTPOSTS'
    GLACIER_IR = 'GLACIER_IR'
    SNOW = 'SNOW'


class StorageClassAnalysisSchemaVersion(Enum):
    V_1 = 'V_1'


class Suffix(RootModel[str]):
    root: str


class TagCount(RootModel[int]):
    root: int


class TaggingDirective(Enum):
    COPY = 'COPY'
    REPLACE = 'REPLACE'


class TaggingHeader(RootModel[str]):
    root: str


class TargetBucket(RootModel[str]):
    root: str


class TargetPrefix(RootModel[str]):
    root: str


class Tier(Enum):
    Standard = 'Standard'
    Bulk = 'Bulk'
    Expedited = 'Expedited'


class Tiering(BaseModel):
    AccessTier: IntelligentTieringAccessTier
    Days: IntelligentTieringDays


class TieringList(RootModel[List[Tiering]]):
    root: List[Tiering]


class Token(RootModel[str]):
    root: str


class TopicArn(RootModel[str]):
    root: str


class TopicConfigurationDeprecated(BaseModel):
    Event_1: Optional[Event] = Field(None, alias='Event')
    Events: Optional[EventList] = None
    Id: Optional[NotificationId] = None
    Topic: Optional[TopicArn] = None


class TransitionStorageClass(Enum):
    GLACIER = 'GLACIER'
    STANDARD_IA = 'STANDARD_IA'
    ONEZONE_IA = 'ONEZONE_IA'
    INTELLIGENT_TIERING = 'INTELLIGENT_TIERING'
    DEEP_ARCHIVE = 'DEEP_ARCHIVE'
    GLACIER_IR = 'GLACIER_IR'


class Type(Enum):
    CanonicalUser = 'CanonicalUser'
    AmazonCustomerByEmail = 'AmazonCustomerByEmail'
    Group = 'Group'


class URI(RootModel[str]):
    root: str


class UploadIdMarker(RootModel[str]):
    root: str


class UploadPartCopyRequest(BaseModel):
    pass


class UploadPartOutput(BaseModel):
    pass


class UploadPartRequest(BaseModel):
    Body_1: Optional[Body] = Field(None, alias='Body')


class Value(RootModel[str]):
    root: str


class VersionCount(RootModel[int]):
    root: int


class VersionIdMarker(RootModel[str]):
    root: str


class VersioningConfiguration(BaseModel):
    MFADelete_1: Optional[MFADelete] = Field(None, alias='MFADelete')
    Status: Optional[BucketVersioningStatus] = None


class WebsiteRedirectLocation(RootModel[str]):
    root: str


class Years(RootModel[int]):
    root: int


class WriteGetObjectResponseXAmzRequestRouteXAmzRequestTokenPostRequest(BaseModel):
    Body: Optional[str] = Field(None, description='The object data.')
    x_amz_meta_: Optional[Dict[str, MetadataValue]] = Field(
        None,
        alias='x-amz-meta-',
        description='A map of metadata to store with the object in S3.',
    )


class XAmzFwdHeaderXAmzObjectLockMode(Enum):
    GOVERNANCE = 'GOVERNANCE'
    COMPLIANCE = 'COMPLIANCE'


class XAmzFwdHeaderXAmzObjectLockLegalHold(Enum):
    ON = 'ON'
    OFF = 'OFF'


class XAmzFwdHeaderXAmzReplicationStatus(Enum):
    COMPLETE = 'COMPLETE'
    PENDING = 'PENDING'
    FAILED = 'FAILED'
    REPLICA = 'REPLICA'


class XAmzFwdHeaderXAmzRequestCharged(Enum):
    requester = 'requester'


class XAmzFwdHeaderXAmzServerSideEncryption(Enum):
    AES256 = 'AES256'
    aws_kms = 'aws:kms'


class XAmzFwdHeaderXAmzStorageClass(Enum):
    STANDARD = 'STANDARD'
    REDUCED_REDUNDANCY = 'REDUCED_REDUNDANCY'
    STANDARD_IA = 'STANDARD_IA'
    ONEZONE_IA = 'ONEZONE_IA'
    INTELLIGENT_TIERING = 'INTELLIGENT_TIERING'
    GLACIER = 'GLACIER'
    DEEP_ARCHIVE = 'DEEP_ARCHIVE'
    OUTPOSTS = 'OUTPOSTS'
    GLACIER_IR = 'GLACIER_IR'
    SNOW = 'SNOW'


class XAmzRequestPayer(Enum):
    requester = 'requester'


class FieldBucketPutRequest(BaseModel):
    CreateBucketConfiguration_1: Optional[CreateBucketConfiguration] = Field(
        None,
        alias='CreateBucketConfiguration',
        description='The configuration information for the bucket.',
    )


class XAmzAcl(Enum):
    private = 'private'
    public_read = 'public-read'
    public_read_write = 'public-read-write'
    authenticated_read = 'authenticated-read'


class XAmzObjectOwnership(Enum):
    BucketOwnerPreferred = 'BucketOwnerPreferred'
    ObjectWriter = 'ObjectWriter'
    BucketOwnerEnforced = 'BucketOwnerEnforced'


class Accelerate(Enum):
    boolean_True = True


class AccelerateConfiguration(BaseModel):
    Status: Optional[BucketAccelerateStatus] = None


class FieldBucketAcceleratePutRequest(BaseModel):
    AccelerateConfiguration_1: AccelerateConfiguration = Field(
        ...,
        alias='AccelerateConfiguration',
        description='Configures the transfer acceleration state for an Amazon S3 bucket. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html">Amazon S3 Transfer Acceleration</a> in the <i>Amazon S3 User Guide</i>.',
    )


class XAmzSdkChecksumAlgorithm(Enum):
    CRC32 = 'CRC32'
    CRC32C = 'CRC32C'
    SHA1 = 'SHA1'
    SHA256 = 'SHA256'


class Acl(Enum):
    boolean_True = True


class Analytics(Enum):
    boolean_True = True


class Cors(Enum):
    boolean_True = True


class Delete1(Enum):
    boolean_True = True


class Encryption1(Enum):
    boolean_True = True


class ServerSideEncryptionConfiguration1(BaseModel):
    Rules: Optional[ServerSideEncryptionRules] = None


class FieldBucketEncryptionPutRequest(BaseModel):
    ServerSideEncryptionConfiguration: ServerSideEncryptionConfiguration1 = Field(
        ..., description='Specifies the default server-side-encryption configuration.'
    )


class IntelligentTiering(Enum):
    boolean_True = True


class Inventory(Enum):
    boolean_True = True


class Lifecycle(Enum):
    boolean_True = True


class ListType(Enum):
    field_2 = '2'


class Location1(Enum):
    boolean_True = True


class Logging(Enum):
    boolean_True = True


class Metrics1(Enum):
    boolean_True = True


class Notification(Enum):
    boolean_True = True


class ObjectLock(Enum):
    boolean_True = True


class OwnershipControls1(Enum):
    boolean_True = True


class OwnershipControls6(BaseModel):
    Rules: Optional[OwnershipControlsRules] = None


class FieldBucketOwnershipControlsPutRequest(BaseModel):
    OwnershipControls: OwnershipControls6 = Field(
        ..., description="The container element for a bucket's ownership controls."
    )


class OwnershipControls7(Enum):
    boolean_True = True


class Policy1(Enum):
    boolean_True = True


class FieldBucketPolicyPutRequest(BaseModel):
    Policy: str = Field(..., description='The bucket policy as a JSON document.')


class PolicyStatus1(Enum):
    boolean_True = True


class PublicAccessBlock(Enum):
    boolean_True = True


class PublicAccessBlockConfiguration(BaseModel):
    BlockPublicAcls: Optional[Setting] = None
    BlockPublicPolicy: Optional[Setting] = None
    IgnorePublicAcls: Optional[Setting] = None
    RestrictPublicBuckets: Optional[Setting] = None


class FieldBucketPublicAccessBlockPutRequest(BaseModel):
    PublicAccessBlockConfiguration_1: PublicAccessBlockConfiguration = Field(
        ...,
        alias='PublicAccessBlockConfiguration',
        description='The PublicAccessBlock configuration that you want to apply to this Amazon S3 bucket. You can enable the configuration options in any combination. For more information about when Amazon S3 considers a bucket or object public, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html#access-control-block-public-access-policy-status">The Meaning of "Public"</a> in the <i>Amazon S3 User Guide</i>. ',
    )


class Replication(Enum):
    boolean_True = True


class RequestPayment(Enum):
    boolean_True = True


class RequestPaymentConfiguration1(BaseModel):
    Payer_1: Optional[Payer] = Field(None, alias='Payer')


class FieldBucketRequestPaymentPutRequest(BaseModel):
    RequestPaymentConfiguration: RequestPaymentConfiguration1 = Field(
        ..., description='Container for Payer.'
    )


class Tagging1(Enum):
    boolean_True = True


class Uploads(Enum):
    boolean_True = True


class Versioning(Enum):
    boolean_True = True


class FieldBucketVersioningPutRequest(BaseModel):
    VersioningConfiguration_1: VersioningConfiguration = Field(
        ...,
        alias='VersioningConfiguration',
        description='Describes the versioning state of an Amazon S3 bucket. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTVersioningStatus.html">PUT Bucket versioning</a> in the <i>Amazon S3 API Reference</i>.',
    )


class Versions(Enum):
    boolean_True = True


class Website(Enum):
    boolean_True = True


class XAmzChecksumMode(Enum):
    ENABLED = 'ENABLED'


class FieldBucketKeyPutRequest(BaseModel):
    Body: Optional[str] = Field(None, description='Object data.')
    x_amz_meta_: Optional[Dict[str, MetadataValue]] = Field(
        None,
        alias='x-amz-meta-',
        description='A map of metadata to store with the object in S3.',
    )


class XAmzAcl2(Enum):
    private = 'private'
    public_read = 'public-read'
    public_read_write = 'public-read-write'
    authenticated_read = 'authenticated-read'
    aws_exec_read = 'aws-exec-read'
    bucket_owner_read = 'bucket-owner-read'
    bucket_owner_full_control = 'bucket-owner-full-control'


class XAmzServerSideEncryption(Enum):
    AES256 = 'AES256'
    aws_kms = 'aws:kms'


class XAmzStorageClass(Enum):
    STANDARD = 'STANDARD'
    REDUCED_REDUNDANCY = 'REDUCED_REDUNDANCY'
    STANDARD_IA = 'STANDARD_IA'
    ONEZONE_IA = 'ONEZONE_IA'
    INTELLIGENT_TIERING = 'INTELLIGENT_TIERING'
    GLACIER = 'GLACIER'
    DEEP_ARCHIVE = 'DEEP_ARCHIVE'
    OUTPOSTS = 'OUTPOSTS'
    GLACIER_IR = 'GLACIER_IR'
    SNOW = 'SNOW'


class XAmzObjectLockMode(Enum):
    GOVERNANCE = 'GOVERNANCE'
    COMPLIANCE = 'COMPLIANCE'


class XAmzObjectLockLegalHold(Enum):
    ON = 'ON'
    OFF = 'OFF'


class Attributes(Enum):
    boolean_True = True


class XAmzObjectAttributes(RootModel[List[ObjectAttributes]]):
    root: List[ObjectAttributes]


class LegalHold(Enum):
    boolean_True = True


class LegalHold3(BaseModel):
    Status: Optional[ObjectLockLegalHoldStatus] = None


class FieldBucketKeyLegalHoldPutRequest(BaseModel):
    LegalHold: Optional[LegalHold3] = Field(
        None, description='A legal hold configuration for an object.'
    )


class LegalHold4(Enum):
    boolean_True = True


class FieldBucketKeyPartNumberUploadIdPutRequest(BaseModel):
    Body: Optional[str] = Field(None, description='Object data.')


class Restore1(Enum):
    boolean_True = True


class Retention(Enum):
    boolean_True = True


class Retention3(BaseModel):
    Mode: Optional[ObjectLockRetentionMode] = None
    RetainUntilDate: Optional[Date] = None


class FieldBucketKeyRetentionPutRequest(BaseModel):
    Retention: Optional[Retention3] = Field(
        None, description='A Retention configuration for an object.'
    )


class Retention4(Enum):
    boolean_True = True


class Select(Enum):
    boolean_True = True


class SelectType(Enum):
    field_2 = '2'


class ScanRange(BaseModel):
    End_1: Optional[End] = Field(None, alias='End')
    Start_1: Optional[Start] = Field(None, alias='Start')


class Torrent(Enum):
    boolean_True = True


class FieldBucketKeyUploadsPostRequest(BaseModel):
    x_amz_meta_: Optional[Dict[str, MetadataValue]] = Field(
        None,
        alias='x-amz-meta-',
        description='A map of metadata to store with the object in S3.',
    )


class XAmzChecksumAlgorithm(Enum):
    CRC32 = 'CRC32'
    CRC32C = 'CRC32C'
    SHA1 = 'SHA1'
    SHA256 = 'SHA256'


class FieldBucketKeyXAmzCopySourcePutRequest(BaseModel):
    x_amz_meta_: Optional[Dict[str, MetadataValue]] = Field(
        None,
        alias='x-amz-meta-',
        description='A map of metadata to store with the object in S3.',
    )


class XAmzMetadataDirective(Enum):
    COPY = 'COPY'
    REPLACE = 'REPLACE'


class XAmzTaggingDirective(Enum):
    COPY = 'COPY'
    REPLACE = 'REPLACE'


class AbortIncompleteMultipartUpload(BaseModel):
    DaysAfterInitiation_1: Optional[DaysAfterInitiation] = Field(
        None, alias='DaysAfterInitiation'
    )


class AccessControlTranslation(BaseModel):
    Owner: OwnerOverride


class AnalyticsS3BucketDestination(BaseModel):
    Bucket: BucketName
    BucketAccountId: Optional[AccountId] = None
    Format: AnalyticsS3ExportFileFormat
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')


class Bucket(BaseModel):
    CreationDate_1: Optional[CreationDate] = Field(None, alias='CreationDate')
    Name: Optional[BucketName] = None


class Buckets(RootModel[List[Bucket]]):
    root: List[Bucket]


class CORSRule(BaseModel):
    AllowedHeaders_1: Optional[AllowedHeaders] = Field(None, alias='AllowedHeaders')
    AllowedMethods_1: AllowedMethods = Field(..., alias='AllowedMethods')
    AllowedOrigins_1: AllowedOrigins = Field(..., alias='AllowedOrigins')
    ExposeHeaders_1: Optional[ExposeHeaders] = Field(None, alias='ExposeHeaders')
    ID_1: Optional[ID] = Field(None, alias='ID')
    MaxAgeSeconds_1: Optional[MaxAgeSeconds] = Field(None, alias='MaxAgeSeconds')


class CORSRules(RootModel[List[CORSRule]]):
    root: List[CORSRule]


class CSVInput(BaseModel):
    AllowQuotedRecordDelimiter_1: Optional[AllowQuotedRecordDelimiter] = Field(
        None, alias='AllowQuotedRecordDelimiter'
    )
    Comments_1: Optional[Comments] = Field(None, alias='Comments')
    FieldDelimiter_1: Optional[FieldDelimiter] = Field(None, alias='FieldDelimiter')
    FileHeaderInfo_1: Optional[FileHeaderInfo] = Field(None, alias='FileHeaderInfo')
    QuoteCharacter_1: Optional[QuoteCharacter] = Field(None, alias='QuoteCharacter')
    QuoteEscapeCharacter_1: Optional[QuoteEscapeCharacter] = Field(
        None, alias='QuoteEscapeCharacter'
    )
    RecordDelimiter_1: Optional[RecordDelimiter] = Field(None, alias='RecordDelimiter')


class CSVOutput(BaseModel):
    FieldDelimiter_1: Optional[FieldDelimiter] = Field(None, alias='FieldDelimiter')
    QuoteCharacter_1: Optional[QuoteCharacter] = Field(None, alias='QuoteCharacter')
    QuoteEscapeCharacter_1: Optional[QuoteEscapeCharacter] = Field(
        None, alias='QuoteEscapeCharacter'
    )
    QuoteFields_1: Optional[QuoteFields] = Field(None, alias='QuoteFields')
    RecordDelimiter_1: Optional[RecordDelimiter] = Field(None, alias='RecordDelimiter')


class Checksum(BaseModel):
    ChecksumCRC32_1: Optional[ChecksumCRC32] = Field(None, alias='ChecksumCRC32')
    ChecksumCRC32C_1: Optional[ChecksumCRC32C] = Field(None, alias='ChecksumCRC32C')
    ChecksumSHA1_1: Optional[ChecksumSHA1] = Field(None, alias='ChecksumSHA1')
    ChecksumSHA256_1: Optional[ChecksumSHA256] = Field(None, alias='ChecksumSHA256')


class CloudFunctionConfiguration(BaseModel):
    CloudFunction_1: Optional[CloudFunction] = Field(None, alias='CloudFunction')
    Event_1: Optional[Event] = Field(None, alias='Event')
    Events: Optional[EventList] = None
    Id: Optional[NotificationId] = None
    InvocationRole: Optional[CloudFunctionInvocationRole] = None


class CommonPrefix(BaseModel):
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')


class CommonPrefixList(RootModel[List[CommonPrefix]]):
    root: List[CommonPrefix]


class CompleteMultipartUploadOutput(BaseModel):
    Bucket: Optional[BucketName] = None
    ChecksumCRC32_1: Optional[ChecksumCRC32] = Field(None, alias='ChecksumCRC32')
    ChecksumCRC32C_1: Optional[ChecksumCRC32C] = Field(None, alias='ChecksumCRC32C')
    ChecksumSHA1_1: Optional[ChecksumSHA1] = Field(None, alias='ChecksumSHA1')
    ChecksumSHA256_1: Optional[ChecksumSHA256] = Field(None, alias='ChecksumSHA256')
    ETag_1: Optional[ETag] = Field(None, alias='ETag')
    Key: Optional[ObjectKey] = None
    Location_1: Optional[Location] = Field(None, alias='Location')


class CompletedPart(BaseModel):
    ChecksumCRC32_1: Optional[ChecksumCRC32] = Field(None, alias='ChecksumCRC32')
    ChecksumCRC32C_1: Optional[ChecksumCRC32C] = Field(None, alias='ChecksumCRC32C')
    ChecksumSHA1_1: Optional[ChecksumSHA1] = Field(None, alias='ChecksumSHA1')
    ChecksumSHA256_1: Optional[ChecksumSHA256] = Field(None, alias='ChecksumSHA256')
    ETag_1: Optional[ETag] = Field(None, alias='ETag')
    PartNumber_1: Optional[PartNumber] = Field(None, alias='PartNumber')


class CompletedPartList(RootModel[List[CompletedPart]]):
    root: List[CompletedPart]


class Condition(BaseModel):
    HttpErrorCodeReturnedEquals_1: Optional[HttpErrorCodeReturnedEquals] = Field(
        None, alias='HttpErrorCodeReturnedEquals'
    )
    KeyPrefixEquals_1: Optional[KeyPrefixEquals] = Field(None, alias='KeyPrefixEquals')


class CopyObjectResult(BaseModel):
    ChecksumCRC32_1: Optional[ChecksumCRC32] = Field(None, alias='ChecksumCRC32')
    ChecksumCRC32C_1: Optional[ChecksumCRC32C] = Field(None, alias='ChecksumCRC32C')
    ChecksumSHA1_1: Optional[ChecksumSHA1] = Field(None, alias='ChecksumSHA1')
    ChecksumSHA256_1: Optional[ChecksumSHA256] = Field(None, alias='ChecksumSHA256')
    ETag_1: Optional[ETag] = Field(None, alias='ETag')
    LastModified_1: Optional[LastModified] = Field(None, alias='LastModified')


class CopyPartResult(BaseModel):
    ChecksumCRC32_1: Optional[ChecksumCRC32] = Field(None, alias='ChecksumCRC32')
    ChecksumCRC32C_1: Optional[ChecksumCRC32C] = Field(None, alias='ChecksumCRC32C')
    ChecksumSHA1_1: Optional[ChecksumSHA1] = Field(None, alias='ChecksumSHA1')
    ChecksumSHA256_1: Optional[ChecksumSHA256] = Field(None, alias='ChecksumSHA256')
    ETag_1: Optional[ETag] = Field(None, alias='ETag')
    LastModified_1: Optional[LastModified] = Field(None, alias='LastModified')


class CreateMultipartUploadOutput(BaseModel):
    Bucket: Optional[BucketName] = None
    Key: Optional[ObjectKey] = None
    UploadId: Optional[MultipartUploadId] = None


class DefaultRetention(BaseModel):
    Days_1: Optional[Days] = Field(None, alias='Days')
    Mode: Optional[ObjectLockRetentionMode] = None
    Years_1: Optional[Years] = Field(None, alias='Years')


class DeleteMarkerEntry(BaseModel):
    IsLatest_1: Optional[IsLatest] = Field(None, alias='IsLatest')
    Key: Optional[ObjectKey] = None
    LastModified_1: Optional[LastModified] = Field(None, alias='LastModified')
    Owner_1: Optional[Owner] = Field(None, alias='Owner')
    VersionId: Optional[ObjectVersionId] = None


class DeleteMarkerReplication(BaseModel):
    Status: Optional[DeleteMarkerReplicationStatus] = None


class DeleteMarkers(RootModel[List[DeleteMarkerEntry]]):
    root: List[DeleteMarkerEntry]


class DeletedObject(BaseModel):
    DeleteMarker_1: Optional[DeleteMarker] = Field(None, alias='DeleteMarker')
    DeleteMarkerVersionId_1: Optional[DeleteMarkerVersionId] = Field(
        None, alias='DeleteMarkerVersionId'
    )
    Key: Optional[ObjectKey] = None
    VersionId: Optional[ObjectVersionId] = None


class DeletedObjects(RootModel[List[DeletedObject]]):
    root: List[DeletedObject]


class Encryption(BaseModel):
    EncryptionType: ServerSideEncryption
    KMSContext_1: Optional[KMSContext] = Field(None, alias='KMSContext')
    KMSKeyId: Optional[SSEKMSKeyId] = None


class EncryptionConfiguration(BaseModel):
    ReplicaKmsKeyID_1: Optional[ReplicaKmsKeyID] = Field(None, alias='ReplicaKmsKeyID')


class Error(BaseModel):
    Code_1: Optional[Code] = Field(None, alias='Code')
    Key: Optional[ObjectKey] = None
    Message_1: Optional[Message] = Field(None, alias='Message')
    VersionId: Optional[ObjectVersionId] = None


class ErrorDocument(BaseModel):
    Key: ObjectKey


class Errors(RootModel[List[Error]]):
    root: List[Error]


class ExistingObjectReplication(BaseModel):
    Status: ExistingObjectReplicationStatus


class FilterRule(BaseModel):
    Name: Optional[FilterRuleName] = None
    Value: Optional[FilterRuleValue] = None


class FilterRuleList(RootModel[List[FilterRule]]):
    root: List[FilterRule] = Field(
        ...,
        description='A list of containers for the key-value pair that defines the criteria for the filter rule.',
    )


class GetBucketCorsOutput(BaseModel):
    CORSRules_1: Optional[CORSRules] = Field(None, alias='CORSRules')


class GetBucketPolicyOutput(BaseModel):
    Policy_1: Optional[Policy] = Field(None, alias='Policy')


class GetBucketPolicyStatusOutput(BaseModel):
    PolicyStatus_1: Optional[PolicyStatus] = Field(None, alias='PolicyStatus')


class GetBucketRequestPaymentOutput(BaseModel):
    Payer_1: Optional[Payer] = Field(None, alias='Payer')


class GetBucketVersioningOutput(BaseModel):
    MFADelete: Optional[MFADeleteStatus] = None
    Status: Optional[BucketVersioningStatus] = None


class GlacierJobParameters(BaseModel):
    Tier_1: Tier = Field(..., alias='Tier')


class Grantee(BaseModel):
    DisplayName_1: Optional[DisplayName] = Field(None, alias='DisplayName')
    EmailAddress_1: Optional[EmailAddress] = Field(None, alias='EmailAddress')
    ID_1: Optional[ID] = Field(None, alias='ID')
    Type_1: Type = Field(..., alias='Type')
    URI_1: Optional[URI] = Field(None, alias='URI')


class IndexDocument(BaseModel):
    Suffix_1: Suffix = Field(..., alias='Suffix')


class InventoryFilter(BaseModel):
    Prefix_1: Prefix = Field(..., alias='Prefix')


class JSONInput(BaseModel):
    Type: Optional[JSONType] = None


class JSONOutput(BaseModel):
    RecordDelimiter_1: Optional[RecordDelimiter] = Field(None, alias='RecordDelimiter')


class ListBucketsOutput(BaseModel):
    Buckets_1: Optional[Buckets] = Field(None, alias='Buckets')
    Owner_1: Optional[Owner] = Field(None, alias='Owner')


class Metadata(RootModel[Optional[Dict[str, MetadataValue]]]):
    root: Optional[Dict[str, MetadataValue]] = None


class MetadataEntry(BaseModel):
    Name: Optional[MetadataKey] = None
    Value: Optional[MetadataValue] = None


class Metrics(BaseModel):
    EventThreshold: Optional[ReplicationTimeValue] = None
    Status: MetricsStatus


class MultipartUpload(BaseModel):
    ChecksumAlgorithm_1: Optional[ChecksumAlgorithm] = Field(
        None, alias='ChecksumAlgorithm'
    )
    Initiated_1: Optional[Initiated] = Field(None, alias='Initiated')
    Initiator_1: Optional[Initiator] = Field(None, alias='Initiator')
    Key: Optional[ObjectKey] = None
    Owner_1: Optional[Owner] = Field(None, alias='Owner')
    StorageClass_1: Optional[StorageClass] = Field(None, alias='StorageClass')
    UploadId: Optional[MultipartUploadId] = None


class MultipartUploadList(RootModel[List[MultipartUpload]]):
    root: List[MultipartUpload]


class NoncurrentVersionExpiration(BaseModel):
    NewerNoncurrentVersions: Optional[VersionCount] = None
    NoncurrentDays: Optional[Days] = None


class NoncurrentVersionTransition(BaseModel):
    NewerNoncurrentVersions: Optional[VersionCount] = None
    NoncurrentDays: Optional[Days] = None
    StorageClass: Optional[TransitionStorageClass] = None


class NoncurrentVersionTransitionList(RootModel[List[NoncurrentVersionTransition]]):
    root: List[NoncurrentVersionTransition]


class NotificationConfigurationDeprecated(BaseModel):
    CloudFunctionConfiguration_1: Optional[CloudFunctionConfiguration] = Field(
        None, alias='CloudFunctionConfiguration'
    )
    QueueConfiguration: Optional[QueueConfigurationDeprecated] = None
    TopicConfiguration: Optional[TopicConfigurationDeprecated] = None


class Object(BaseModel):
    ChecksumAlgorithm: Optional[ChecksumAlgorithmList] = None
    ETag_1: Optional[ETag] = Field(None, alias='ETag')
    Key: Optional[ObjectKey] = None
    LastModified_1: Optional[LastModified] = Field(None, alias='LastModified')
    Owner_1: Optional[Owner] = Field(None, alias='Owner')
    Size_1: Optional[Size] = Field(None, alias='Size')
    StorageClass: Optional[ObjectStorageClass] = None


class ObjectIdentifier(BaseModel):
    Key: ObjectKey
    VersionId: Optional[ObjectVersionId] = None


class ObjectIdentifierList(RootModel[List[ObjectIdentifier]]):
    root: List[ObjectIdentifier]


class ObjectList(RootModel[List[Object]]):
    root: List[Object]


class ObjectLockLegalHold(BaseModel):
    Status: Optional[ObjectLockLegalHoldStatus] = None


class ObjectLockRetention(BaseModel):
    Mode: Optional[ObjectLockRetentionMode] = None
    RetainUntilDate: Optional[Date] = None


class ObjectLockRule(BaseModel):
    DefaultRetention_1: Optional[DefaultRetention] = Field(
        None, alias='DefaultRetention'
    )


class ObjectPart(BaseModel):
    ChecksumCRC32_1: Optional[ChecksumCRC32] = Field(None, alias='ChecksumCRC32')
    ChecksumCRC32C_1: Optional[ChecksumCRC32C] = Field(None, alias='ChecksumCRC32C')
    ChecksumSHA1_1: Optional[ChecksumSHA1] = Field(None, alias='ChecksumSHA1')
    ChecksumSHA256_1: Optional[ChecksumSHA256] = Field(None, alias='ChecksumSHA256')
    PartNumber_1: Optional[PartNumber] = Field(None, alias='PartNumber')
    Size_1: Optional[Size] = Field(None, alias='Size')


class ObjectVersion(BaseModel):
    ChecksumAlgorithm: Optional[ChecksumAlgorithmList] = None
    ETag_1: Optional[ETag] = Field(None, alias='ETag')
    IsLatest_1: Optional[IsLatest] = Field(None, alias='IsLatest')
    Key: Optional[ObjectKey] = None
    LastModified_1: Optional[LastModified] = Field(None, alias='LastModified')
    Owner_1: Optional[Owner] = Field(None, alias='Owner')
    Size_1: Optional[Size] = Field(None, alias='Size')
    StorageClass: Optional[ObjectVersionStorageClass] = None
    VersionId: Optional[ObjectVersionId] = None


class ObjectVersionList(RootModel[List[ObjectVersion]]):
    root: List[ObjectVersion]


class OutputSerialization(BaseModel):
    CSV: Optional[CSVOutput] = None
    JSON: Optional[JSONOutput] = None


class OwnershipControls(BaseModel):
    Rules: OwnershipControlsRules


class Part(BaseModel):
    ChecksumCRC32_1: Optional[ChecksumCRC32] = Field(None, alias='ChecksumCRC32')
    ChecksumCRC32C_1: Optional[ChecksumCRC32C] = Field(None, alias='ChecksumCRC32C')
    ChecksumSHA1_1: Optional[ChecksumSHA1] = Field(None, alias='ChecksumSHA1')
    ChecksumSHA256_1: Optional[ChecksumSHA256] = Field(None, alias='ChecksumSHA256')
    ETag_1: Optional[ETag] = Field(None, alias='ETag')
    LastModified_1: Optional[LastModified] = Field(None, alias='LastModified')
    PartNumber_1: Optional[PartNumber] = Field(None, alias='PartNumber')
    Size_1: Optional[Size] = Field(None, alias='Size')


class Parts(RootModel[List[Part]]):
    root: List[Part]


class PartsList(RootModel[List[ObjectPart]]):
    root: List[ObjectPart]


class PutBucketAccelerateConfigurationRequest(BaseModel):
    AccelerateConfiguration_1: AccelerateConfiguration = Field(
        ..., alias='AccelerateConfiguration'
    )


class PutBucketNotificationRequest(BaseModel):
    NotificationConfiguration: NotificationConfigurationDeprecated


class PutBucketOwnershipControlsRequest(BaseModel):
    OwnershipControls_1: OwnershipControls = Field(..., alias='OwnershipControls')


class PutBucketRequestPaymentRequest(BaseModel):
    RequestPaymentConfiguration_1: RequestPaymentConfiguration = Field(
        ..., alias='RequestPaymentConfiguration'
    )


class PutBucketVersioningRequest(BaseModel):
    VersioningConfiguration_1: VersioningConfiguration = Field(
        ..., alias='VersioningConfiguration'
    )


class PutObjectLegalHoldRequest(BaseModel):
    LegalHold: Optional[ObjectLockLegalHold] = None


class PutObjectRequest(BaseModel):
    Body_1: Optional[Body] = Field(None, alias='Body')
    Metadata_1: Optional[Metadata] = Field(None, alias='Metadata')


class PutObjectRetentionRequest(BaseModel):
    Retention: Optional[ObjectLockRetention] = None


class PutPublicAccessBlockRequest(BaseModel):
    PublicAccessBlockConfiguration_1: PublicAccessBlockConfiguration = Field(
        ..., alias='PublicAccessBlockConfiguration'
    )


class Redirect(BaseModel):
    HostName_1: Optional[HostName] = Field(None, alias='HostName')
    HttpRedirectCode_1: Optional[HttpRedirectCode] = Field(
        None, alias='HttpRedirectCode'
    )
    Protocol_1: Optional[Protocol] = Field(None, alias='Protocol')
    ReplaceKeyPrefixWith_1: Optional[ReplaceKeyPrefixWith] = Field(
        None, alias='ReplaceKeyPrefixWith'
    )
    ReplaceKeyWith_1: Optional[ReplaceKeyWith] = Field(None, alias='ReplaceKeyWith')


class ReplicaModifications(BaseModel):
    Status: ReplicaModificationsStatus


class ReplicationTime(BaseModel):
    Status: ReplicationTimeStatus
    Time: ReplicationTimeValue


class RoutingRule(BaseModel):
    Condition_1: Optional[Condition] = Field(None, alias='Condition')
    Redirect_1: Redirect = Field(..., alias='Redirect')


class RoutingRules(RootModel[List[RoutingRule]]):
    root: List[RoutingRule]


class S3KeyFilter(BaseModel):
    FilterRules: Optional[FilterRuleList] = None


class SSEKMS(BaseModel):
    KeyId: SSEKMSKeyId


class SelectObjectContentEventStream(BaseModel):
    Cont: Optional[ContinuationEvent] = None
    End: Optional[EndEvent] = None
    Progress: Optional[ProgressEvent] = None
    Records: Optional[RecordsEvent] = None
    Stats: Optional[StatsEvent] = None


class SelectObjectContentOutput(BaseModel):
    Payload: Optional[SelectObjectContentEventStream] = None


class ServerSideEncryptionConfiguration(BaseModel):
    Rules: ServerSideEncryptionRules


class SseKmsEncryptedObjects(BaseModel):
    Status: SseKmsEncryptedObjectsStatus


class Tag(BaseModel):
    Key: ObjectKey
    Value_1: Value = Field(..., alias='Value')


class TagSet(RootModel[List[Tag]]):
    root: List[Tag]


class Tagging(BaseModel):
    TagSet_1: TagSet = Field(..., alias='TagSet')


class TargetGrant(BaseModel):
    Grantee_1: Optional[Grantee] = Field(None, alias='Grantee')
    Permission: Optional[BucketLogsPermission] = None


class TargetGrants(RootModel[List[TargetGrant]]):
    root: List[TargetGrant]


class Transition(BaseModel):
    Date_1: Optional[Date] = Field(None, alias='Date')
    Days_1: Optional[Days] = Field(None, alias='Days')
    StorageClass: Optional[TransitionStorageClass] = None


class TransitionList(RootModel[List[Transition]]):
    root: List[Transition]


class UploadPartCopyOutput(BaseModel):
    CopyPartResult_1: Optional[CopyPartResult] = Field(None, alias='CopyPartResult')


class UserMetadata(RootModel[List[MetadataEntry]]):
    root: List[MetadataEntry]


class WebsiteConfiguration(BaseModel):
    ErrorDocument_1: Optional[ErrorDocument] = Field(None, alias='ErrorDocument')
    IndexDocument_1: Optional[IndexDocument] = Field(None, alias='IndexDocument')
    RedirectAllRequestsTo_1: Optional[RedirectAllRequestsTo] = Field(
        None, alias='RedirectAllRequestsTo'
    )
    RoutingRules_1: Optional[RoutingRules] = Field(None, alias='RoutingRules')


class WriteGetObjectResponseRequest(BaseModel):
    Body_1: Optional[Body] = Field(None, alias='Body')
    Metadata_1: Optional[Metadata] = Field(None, alias='Metadata')


class CORSConfiguration1(BaseModel):
    CORSRules_1: Optional[CORSRules] = Field(None, alias='CORSRules')


class FieldBucketCorsPutRequest(BaseModel):
    CORSConfiguration: CORSConfiguration1 = Field(
        ...,
        description='Describes the cross-origin access configuration for objects in an Amazon S3 bucket. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html">Enabling Cross-Origin Resource Sharing</a> in the <i>Amazon S3 User Guide</i>.',
    )


class Delete2(BaseModel):
    Objects: Optional[ObjectIdentifierList] = None
    Quiet_1: Optional[Quiet] = Field(None, alias='Quiet')


class FieldBucketDeletePostRequest(BaseModel):
    Delete: Delete2 = Field(..., description='Container for the objects to delete.')


class NotificationConfiguration2(BaseModel):
    CloudFunctionConfiguration_1: Optional[CloudFunctionConfiguration] = Field(
        None, alias='CloudFunctionConfiguration'
    )
    QueueConfiguration: Optional[QueueConfigurationDeprecated] = None
    TopicConfiguration: Optional[TopicConfigurationDeprecated] = None


class FieldBucketNotificationDeprecatedPutRequest(BaseModel):
    NotificationConfiguration: NotificationConfiguration2 = Field(
        ...,
        description='The container for the configuration.',
        examples=[
            {
                'QueueConfiguration': {
                    'Event': 's3:ObjectCreated:Put',
                    'Events': ['s3:ObjectCreated:Put'],
                    'Id': 'MDQ2OGQ4NDEtOTBmNi00YTM4LTk0NzYtZDIwN2I3NWQ1NjIx',
                    'Queue': 'arn:aws:sqs:us-east-1:acct-id:S3ObjectCreatedEventQueue',
                },
                'TopicConfiguration': {
                    'Event': 's3:ObjectCreated:Copy',
                    'Events': ['s3:ObjectCreated:Copy'],
                    'Id': 'YTVkMWEzZGUtNTY1NS00ZmE2LWJjYjktMmRlY2QwODFkNTJi',
                    'Topic': 'arn:aws:sns:us-east-1:acct-id:S3ObjectCreatedEventTopic',
                },
            }
        ],
    )


class ObjectLockConfiguration(BaseModel):
    ObjectLockEnabled_1: Optional[ObjectLockEnabled] = Field(
        None, alias='ObjectLockEnabled'
    )
    Rule: Optional[ObjectLockRule] = None


class FieldBucketObjectLockPutRequest(BaseModel):
    ObjectLockConfiguration_1: Optional[ObjectLockConfiguration] = Field(
        None,
        alias='ObjectLockConfiguration',
        description='The container element for Object Lock configuration parameters.',
    )


class Tagging6(BaseModel):
    TagSet_1: Optional[TagSet] = Field(None, alias='TagSet')


class FieldBucketTaggingPutRequest(BaseModel):
    Tagging: Tagging6 = Field(
        ..., description='Container for <code>TagSet</code> elements.'
    )


class FieldBucketWebsitePutRequest(BaseModel):
    WebsiteConfiguration_1: WebsiteConfiguration = Field(
        ...,
        alias='WebsiteConfiguration',
        description='Specifies website configuration parameters for an Amazon S3 bucket.',
    )


class InputSerialization(BaseModel):
    CSV: Optional[CSVInput] = None
    CompressionType_1: Optional[CompressionType] = Field(None, alias='CompressionType')
    JSON: Optional[JSONInput] = None
    Parquet: Optional[ParquetInput] = None


class FieldBucketKeySelectSelectType2PostRequest(BaseModel):
    Expression: str = Field(
        ..., description='The expression that is used to query the object.'
    )
    ExpressionType_1: ExpressionType = Field(
        ...,
        alias='ExpressionType',
        description='The type of the provided expression (for example, SQL).',
    )
    InputSerialization_1: InputSerialization = Field(
        ...,
        alias='InputSerialization',
        description='Describes the serialization format of the object.',
    )
    OutputSerialization_1: OutputSerialization = Field(
        ...,
        alias='OutputSerialization',
        description='Describes how results of the Select job are serialized.',
    )
    RequestProgress_1: Optional[RequestProgress] = Field(
        None,
        alias='RequestProgress',
        description='Container for specifying if periodic <code>QueryProgress</code> messages should be sent.',
    )
    ScanRange_1: Optional[ScanRange] = Field(
        None,
        alias='ScanRange',
        description='Specifies the byte range of the object to get the records from. A record is processed when its first byte is contained by the range. This parameter is optional, but when specified, it must not be empty. See RFC 2616, Section 14.35.1 about how to specify the start and end of the range.',
    )


class FieldBucketKeyTaggingPutRequest(BaseModel):
    Tagging: Tagging6 = Field(
        ..., description='Container for <code>TagSet</code> elements.'
    )


class CompleteMultipartUpload(BaseModel):
    Parts: Optional[CompletedPartList] = None


class FieldBucketKeyUploadIdPostRequest(BaseModel):
    CompleteMultipartUpload_1: Optional[CompleteMultipartUpload] = Field(
        None,
        alias='CompleteMultipartUpload',
        description='The container for the completed multipart upload details.',
    )


class AnalyticsAndOperator(BaseModel):
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Tags: Optional[TagSet] = None


class AnalyticsExportDestination(BaseModel):
    S3BucketDestination: AnalyticsS3BucketDestination


class AnalyticsFilter(BaseModel):
    And: Optional[AnalyticsAndOperator] = None
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Tag_1: Optional[Tag] = Field(None, alias='Tag')


class CORSConfiguration(BaseModel):
    CORSRules_1: CORSRules = Field(..., alias='CORSRules')


class CompletedMultipartUpload(BaseModel):
    Parts: Optional[CompletedPartList] = None


class CopyObjectOutput(BaseModel):
    CopyObjectResult_1: Optional[CopyObjectResult] = Field(
        None, alias='CopyObjectResult'
    )


class CopyObjectRequest(BaseModel):
    Metadata_1: Optional[Metadata] = Field(None, alias='Metadata')


class CreateMultipartUploadRequest(BaseModel):
    Metadata_1: Optional[Metadata] = Field(None, alias='Metadata')


class Delete(BaseModel):
    Objects: ObjectIdentifierList
    Quiet_1: Optional[Quiet] = Field(None, alias='Quiet')


class DeleteObjectsOutput(BaseModel):
    Deleted: Optional[DeletedObjects] = None
    Errors_1: Optional[Errors] = Field(None, alias='Errors')


class DeleteObjectsRequest(BaseModel):
    Delete_1: Delete = Field(..., alias='Delete')


class Destination(BaseModel):
    AccessControlTranslation_1: Optional[AccessControlTranslation] = Field(
        None, alias='AccessControlTranslation'
    )
    Account: Optional[AccountId] = None
    Bucket: BucketName
    EncryptionConfiguration_1: Optional[EncryptionConfiguration] = Field(
        None, alias='EncryptionConfiguration'
    )
    Metrics_1: Optional[Metrics] = Field(None, alias='Metrics')
    ReplicationTime_1: Optional[ReplicationTime] = Field(None, alias='ReplicationTime')
    StorageClass_1: Optional[StorageClass] = Field(None, alias='StorageClass')


class GetBucketEncryptionOutput(BaseModel):
    ServerSideEncryptionConfiguration_1: Optional[ServerSideEncryptionConfiguration] = (
        Field(None, alias='ServerSideEncryptionConfiguration')
    )


class GetBucketOwnershipControlsOutput(BaseModel):
    OwnershipControls_1: Optional[OwnershipControls] = Field(
        None, alias='OwnershipControls'
    )


class GetBucketTaggingOutput(BaseModel):
    TagSet_1: TagSet = Field(..., alias='TagSet')


class GetBucketWebsiteOutput(BaseModel):
    ErrorDocument_1: Optional[ErrorDocument] = Field(None, alias='ErrorDocument')
    IndexDocument_1: Optional[IndexDocument] = Field(None, alias='IndexDocument')
    RedirectAllRequestsTo_1: Optional[RedirectAllRequestsTo] = Field(
        None, alias='RedirectAllRequestsTo'
    )
    RoutingRules_1: Optional[RoutingRules] = Field(None, alias='RoutingRules')


class GetObjectAttributesParts(BaseModel):
    IsTruncated_1: Optional[IsTruncated] = Field(None, alias='IsTruncated')
    MaxParts_1: Optional[MaxParts] = Field(None, alias='MaxParts')
    NextPartNumberMarker_1: Optional[NextPartNumberMarker] = Field(
        None, alias='NextPartNumberMarker'
    )
    PartNumberMarker_1: Optional[PartNumberMarker] = Field(
        None, alias='PartNumberMarker'
    )
    Parts: Optional[PartsList] = None
    TotalPartsCount: Optional[PartsCount] = None


class GetObjectLegalHoldOutput(BaseModel):
    LegalHold: Optional[ObjectLockLegalHold] = None


class GetObjectOutput(BaseModel):
    Body_1: Optional[Body] = Field(None, alias='Body')
    Metadata_1: Optional[Metadata] = Field(None, alias='Metadata')


class GetObjectRetentionOutput(BaseModel):
    Retention: Optional[ObjectLockRetention] = None


class GetObjectTaggingOutput(BaseModel):
    TagSet_1: TagSet = Field(..., alias='TagSet')


class GetPublicAccessBlockOutput(BaseModel):
    PublicAccessBlockConfiguration_1: Optional[PublicAccessBlockConfiguration] = Field(
        None, alias='PublicAccessBlockConfiguration'
    )


class Grant(BaseModel):
    Grantee_1: Optional[Grantee] = Field(None, alias='Grantee')
    Permission_1: Optional[Permission] = Field(None, alias='Permission')


class Grants(RootModel[List[Grant]]):
    root: List[Grant]


class HeadObjectOutput(BaseModel):
    Metadata_1: Optional[Metadata] = Field(None, alias='Metadata')


class IntelligentTieringAndOperator(BaseModel):
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Tags: Optional[TagSet] = None


class IntelligentTieringFilter(BaseModel):
    And: Optional[IntelligentTieringAndOperator] = None
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Tag_1: Optional[Tag] = Field(None, alias='Tag')


class InventoryEncryption(BaseModel):
    SSEKMS_1: Optional[SSEKMS] = Field(None, alias='SSEKMS')
    SSES3_1: Optional[SSES3] = Field(None, alias='SSES3')


class InventoryS3BucketDestination(BaseModel):
    AccountId_1: Optional[AccountId] = Field(None, alias='AccountId')
    Bucket: BucketName
    Encryption: Optional[InventoryEncryption] = None
    Format: InventoryFormat
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')


class LifecycleRuleAndOperator(BaseModel):
    ObjectSizeGreaterThan: Optional[ObjectSizeGreaterThanBytes] = None
    ObjectSizeLessThan: Optional[ObjectSizeLessThanBytes] = None
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Tags: Optional[TagSet] = None


class LifecycleRuleFilter(BaseModel):
    And: Optional[LifecycleRuleAndOperator] = None
    ObjectSizeGreaterThan: Optional[ObjectSizeGreaterThanBytes] = None
    ObjectSizeLessThan: Optional[ObjectSizeLessThanBytes] = None
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Tag_1: Optional[Tag] = Field(None, alias='Tag')


class ListMultipartUploadsOutput(BaseModel):
    Bucket: Optional[BucketName] = None
    CommonPrefixes: Optional[CommonPrefixList] = None
    Delimiter_1: Optional[Delimiter] = Field(None, alias='Delimiter')
    EncodingType_1: Optional[EncodingType] = Field(None, alias='EncodingType')
    IsTruncated_1: Optional[IsTruncated] = Field(None, alias='IsTruncated')
    KeyMarker_1: Optional[KeyMarker] = Field(None, alias='KeyMarker')
    MaxUploads_1: Optional[MaxUploads] = Field(None, alias='MaxUploads')
    NextKeyMarker_1: Optional[NextKeyMarker] = Field(None, alias='NextKeyMarker')
    NextUploadIdMarker_1: Optional[NextUploadIdMarker] = Field(
        None, alias='NextUploadIdMarker'
    )
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    UploadIdMarker_1: Optional[UploadIdMarker] = Field(None, alias='UploadIdMarker')
    Uploads: Optional[MultipartUploadList] = None


class ListObjectVersionsOutput(BaseModel):
    CommonPrefixes: Optional[CommonPrefixList] = None
    DeleteMarkers_1: Optional[DeleteMarkers] = Field(None, alias='DeleteMarkers')
    Delimiter_1: Optional[Delimiter] = Field(None, alias='Delimiter')
    EncodingType_1: Optional[EncodingType] = Field(None, alias='EncodingType')
    IsTruncated_1: Optional[IsTruncated] = Field(None, alias='IsTruncated')
    KeyMarker_1: Optional[KeyMarker] = Field(None, alias='KeyMarker')
    MaxKeys_1: Optional[MaxKeys] = Field(None, alias='MaxKeys')
    Name: Optional[BucketName] = None
    NextKeyMarker_1: Optional[NextKeyMarker] = Field(None, alias='NextKeyMarker')
    NextVersionIdMarker_1: Optional[NextVersionIdMarker] = Field(
        None, alias='NextVersionIdMarker'
    )
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    VersionIdMarker_1: Optional[VersionIdMarker] = Field(None, alias='VersionIdMarker')
    Versions: Optional[ObjectVersionList] = None


class ListObjectsOutput(BaseModel):
    CommonPrefixes: Optional[CommonPrefixList] = None
    Contents: Optional[ObjectList] = None
    Delimiter_1: Optional[Delimiter] = Field(None, alias='Delimiter')
    EncodingType_1: Optional[EncodingType] = Field(None, alias='EncodingType')
    IsTruncated_1: Optional[IsTruncated] = Field(None, alias='IsTruncated')
    Marker_1: Optional[Marker] = Field(None, alias='Marker')
    MaxKeys_1: Optional[MaxKeys] = Field(None, alias='MaxKeys')
    Name: Optional[BucketName] = None
    NextMarker_1: Optional[NextMarker] = Field(None, alias='NextMarker')
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')


class ListObjectsV2Output(BaseModel):
    CommonPrefixes: Optional[CommonPrefixList] = None
    Contents: Optional[ObjectList] = None
    ContinuationToken: Optional[Token] = None
    Delimiter_1: Optional[Delimiter] = Field(None, alias='Delimiter')
    EncodingType_1: Optional[EncodingType] = Field(None, alias='EncodingType')
    IsTruncated_1: Optional[IsTruncated] = Field(None, alias='IsTruncated')
    KeyCount_1: Optional[KeyCount] = Field(None, alias='KeyCount')
    MaxKeys_1: Optional[MaxKeys] = Field(None, alias='MaxKeys')
    Name: Optional[BucketName] = None
    NextContinuationToken: Optional[NextToken] = None
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    StartAfter_1: Optional[StartAfter] = Field(None, alias='StartAfter')


class ListPartsOutput(BaseModel):
    Bucket: Optional[BucketName] = None
    ChecksumAlgorithm_1: Optional[ChecksumAlgorithm] = Field(
        None, alias='ChecksumAlgorithm'
    )
    Initiator_1: Optional[Initiator] = Field(None, alias='Initiator')
    IsTruncated_1: Optional[IsTruncated] = Field(None, alias='IsTruncated')
    Key: Optional[ObjectKey] = None
    MaxParts_1: Optional[MaxParts] = Field(None, alias='MaxParts')
    NextPartNumberMarker_1: Optional[NextPartNumberMarker] = Field(
        None, alias='NextPartNumberMarker'
    )
    Owner_1: Optional[Owner] = Field(None, alias='Owner')
    PartNumberMarker_1: Optional[PartNumberMarker] = Field(
        None, alias='PartNumberMarker'
    )
    Parts_1: Optional[Parts] = Field(None, alias='Parts')
    StorageClass_1: Optional[StorageClass] = Field(None, alias='StorageClass')
    UploadId: Optional[MultipartUploadId] = None


class LoggingEnabled(BaseModel):
    TargetBucket_1: TargetBucket = Field(..., alias='TargetBucket')
    TargetGrants_1: Optional[TargetGrants] = Field(None, alias='TargetGrants')
    TargetPrefix_1: TargetPrefix = Field(..., alias='TargetPrefix')


class MetricsAndOperator(BaseModel):
    AccessPointArn_1: Optional[AccessPointArn] = Field(None, alias='AccessPointArn')
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Tags: Optional[TagSet] = None


class MetricsFilter(BaseModel):
    AccessPointArn_1: Optional[AccessPointArn] = Field(None, alias='AccessPointArn')
    And: Optional[MetricsAndOperator] = None
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Tag_1: Optional[Tag] = Field(None, alias='Tag')


class NotificationConfigurationFilter(BaseModel):
    Key: Optional[S3KeyFilter] = None


class PutBucketCorsRequest(BaseModel):
    CORSConfiguration_1: CORSConfiguration = Field(..., alias='CORSConfiguration')


class PutBucketEncryptionRequest(BaseModel):
    ServerSideEncryptionConfiguration_1: ServerSideEncryptionConfiguration = Field(
        ..., alias='ServerSideEncryptionConfiguration'
    )


class PutBucketTaggingRequest(BaseModel):
    Tagging_1: Tagging = Field(..., alias='Tagging')


class PutBucketWebsiteRequest(BaseModel):
    WebsiteConfiguration_1: WebsiteConfiguration = Field(
        ..., alias='WebsiteConfiguration'
    )


class PutObjectLockConfigurationRequest(BaseModel):
    ObjectLockConfiguration_1: Optional[ObjectLockConfiguration] = Field(
        None, alias='ObjectLockConfiguration'
    )


class PutObjectTaggingRequest(BaseModel):
    Tagging_1: Tagging = Field(..., alias='Tagging')


class QueueConfiguration(BaseModel):
    Events: EventList
    Filter: Optional[NotificationConfigurationFilter] = None
    Id: Optional[NotificationId] = None
    QueueArn_1: QueueArn = Field(..., alias='QueueArn')


class QueueConfigurationList(RootModel[List[QueueConfiguration]]):
    root: List[QueueConfiguration]


class ReplicationRuleAndOperator(BaseModel):
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Tags: Optional[TagSet] = None


class ReplicationRuleFilter(BaseModel):
    And: Optional[ReplicationRuleAndOperator] = None
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Tag_1: Optional[Tag] = Field(None, alias='Tag')


class Rule(BaseModel):
    AbortIncompleteMultipartUpload_1: Optional[AbortIncompleteMultipartUpload] = Field(
        None, alias='AbortIncompleteMultipartUpload'
    )
    Expiration: Optional[LifecycleExpiration] = None
    ID_1: Optional[ID] = Field(None, alias='ID')
    NoncurrentVersionExpiration_1: Optional[NoncurrentVersionExpiration] = Field(
        None, alias='NoncurrentVersionExpiration'
    )
    NoncurrentVersionTransition_1: Optional[NoncurrentVersionTransition] = Field(
        None, alias='NoncurrentVersionTransition'
    )
    Prefix_1: Prefix = Field(..., alias='Prefix')
    Status: ExpirationStatus
    Transition_1: Optional[Transition] = Field(None, alias='Transition')


class Rules(RootModel[List[Rule]]):
    root: List[Rule]


class S3Location(BaseModel):
    AccessControlList: Optional[Grants] = None
    BucketName_1: BucketName = Field(..., alias='BucketName')
    CannedACL: Optional[ObjectCannedACL] = None
    Encryption_1: Optional[Encryption] = Field(None, alias='Encryption')
    Prefix: LocationPrefix
    StorageClass_1: Optional[StorageClass] = Field(None, alias='StorageClass')
    Tagging_1: Optional[Tagging] = Field(None, alias='Tagging')
    UserMetadata_1: Optional[UserMetadata] = Field(None, alias='UserMetadata')


class SelectObjectContentRequest(BaseModel):
    Expression_1: Expression = Field(..., alias='Expression')
    ExpressionType_1: ExpressionType = Field(..., alias='ExpressionType')
    InputSerialization_1: InputSerialization = Field(..., alias='InputSerialization')
    OutputSerialization_1: OutputSerialization = Field(..., alias='OutputSerialization')
    RequestProgress_1: Optional[RequestProgress] = Field(None, alias='RequestProgress')
    ScanRange_1: Optional[ScanRange] = Field(None, alias='ScanRange')


class SelectParameters(BaseModel):
    Expression_1: Expression = Field(..., alias='Expression')
    ExpressionType_1: ExpressionType = Field(..., alias='ExpressionType')
    InputSerialization_1: InputSerialization = Field(..., alias='InputSerialization')
    OutputSerialization_1: OutputSerialization = Field(..., alias='OutputSerialization')


class SourceSelectionCriteria(BaseModel):
    ReplicaModifications_1: Optional[ReplicaModifications] = Field(
        None, alias='ReplicaModifications'
    )
    SseKmsEncryptedObjects_1: Optional[SseKmsEncryptedObjects] = Field(
        None, alias='SseKmsEncryptedObjects'
    )


class StorageClassAnalysisDataExport(BaseModel):
    Destination: AnalyticsExportDestination
    OutputSchemaVersion: StorageClassAnalysisSchemaVersion


class TopicConfiguration(BaseModel):
    Events: EventList
    Filter: Optional[NotificationConfigurationFilter] = None
    Id: Optional[NotificationId] = None
    TopicArn_1: TopicArn = Field(..., alias='TopicArn')


class TopicConfigurationList(RootModel[List[TopicConfiguration]]):
    root: List[TopicConfiguration]


class AccessControlPolicy(BaseModel):
    Grants_1: Optional[Grants] = Field(None, alias='Grants')
    Owner_1: Optional[Owner] = Field(None, alias='Owner')


class FieldBucketAclPutRequest(BaseModel):
    AccessControlPolicy_1: Optional[AccessControlPolicy] = Field(
        None,
        alias='AccessControlPolicy',
        description='Contains the elements that set the ACL permissions for an object per grantee.',
    )


class IntelligentTieringConfiguration1(BaseModel):
    Filter: Optional[IntelligentTieringFilter] = None
    Id: Optional[IntelligentTieringId] = None
    Status: Optional[IntelligentTieringStatus] = None
    Tierings: Optional[TieringList] = None


class FieldBucketIntelligentTieringIdPutRequest(BaseModel):
    IntelligentTieringConfiguration: IntelligentTieringConfiguration1 = Field(
        ...,
        description='<p>Specifies the S3 Intelligent-Tiering configuration for an Amazon S3 bucket.</p> <p>For information about the S3 Intelligent-Tiering storage class, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html#sc-dynamic-data-access">Storage class for automatically optimizing frequently and infrequently accessed objects</a>.</p>',
    )


class LifecycleConfiguration2(BaseModel):
    Rules_1: Optional[Rules] = Field(None, alias='Rules')


class FieldBucketLifecycleDeprecatedPutRequest(BaseModel):
    LifecycleConfiguration: Optional[LifecycleConfiguration2] = Field(
        None,
        description='Container for lifecycle rules. You can add as many as 1000 rules.',
    )


class BucketLoggingStatus(BaseModel):
    LoggingEnabled_1: Optional[LoggingEnabled] = Field(None, alias='LoggingEnabled')


class FieldBucketLoggingPutRequest(BaseModel):
    BucketLoggingStatus_1: BucketLoggingStatus = Field(
        ...,
        alias='BucketLoggingStatus',
        description='Container for logging status information.',
    )


class MetricsConfiguration1(BaseModel):
    Filter: Optional[MetricsFilter] = None
    Id: Optional[MetricsId] = None


class FieldBucketMetricsIdPutRequest(BaseModel):
    MetricsConfiguration: MetricsConfiguration1 = Field(
        ...,
        description='Specifies a metrics configuration for the CloudWatch request metrics (specified by the metrics configuration ID) from an Amazon S3 bucket. If you\'re updating an existing metrics configuration, note that this is a full replacement of the existing metrics configuration. If you don\'t include the elements you want to keep, they are erased. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUTMetricConfiguration.html">PutBucketMetricsConfiguration</a>.',
    )


class FieldBucketKeyAclPutRequest(BaseModel):
    AccessControlPolicy_1: Optional[AccessControlPolicy] = Field(
        None,
        alias='AccessControlPolicy',
        description='Contains the elements that set the ACL permissions for an object per grantee.',
    )


class CompleteMultipartUploadRequest(BaseModel):
    MultipartUpload: Optional[CompletedMultipartUpload] = None


class GetBucketAclOutput(BaseModel):
    Grants_1: Optional[Grants] = Field(None, alias='Grants')
    Owner_1: Optional[Owner] = Field(None, alias='Owner')


class GetBucketLifecycleOutput(BaseModel):
    Rules_1: Optional[Rules] = Field(None, alias='Rules')


class GetBucketLoggingOutput(BaseModel):
    LoggingEnabled_1: Optional[LoggingEnabled] = Field(None, alias='LoggingEnabled')


class GetObjectAclOutput(BaseModel):
    Grants_1: Optional[Grants] = Field(None, alias='Grants')
    Owner_1: Optional[Owner] = Field(None, alias='Owner')


class GetObjectAttributesOutput(BaseModel):
    Checksum_1: Optional[Checksum] = Field(None, alias='Checksum')
    ETag_1: Optional[ETag] = Field(None, alias='ETag')
    ObjectParts: Optional[GetObjectAttributesParts] = None
    ObjectSize_1: Optional[ObjectSize] = Field(None, alias='ObjectSize')
    StorageClass_1: Optional[StorageClass] = Field(None, alias='StorageClass')


class GetObjectLockConfigurationOutput(BaseModel):
    ObjectLockConfiguration_1: Optional[ObjectLockConfiguration] = Field(
        None, alias='ObjectLockConfiguration'
    )


class IntelligentTieringConfiguration(BaseModel):
    Filter: Optional[IntelligentTieringFilter] = None
    Id: IntelligentTieringId
    Status: IntelligentTieringStatus
    Tierings: TieringList


class IntelligentTieringConfigurationList(
    RootModel[List[IntelligentTieringConfiguration]]
):
    root: List[IntelligentTieringConfiguration]


class InventoryDestination(BaseModel):
    S3BucketDestination: InventoryS3BucketDestination


class LambdaFunctionConfiguration(BaseModel):
    Events: EventList
    Filter: Optional[NotificationConfigurationFilter] = None
    Id: Optional[NotificationId] = None
    LambdaFunctionArn_1: LambdaFunctionArn = Field(..., alias='LambdaFunctionArn')


class LambdaFunctionConfigurationList(RootModel[List[LambdaFunctionConfiguration]]):
    root: List[LambdaFunctionConfiguration]


class LifecycleConfiguration(BaseModel):
    Rules_1: Rules = Field(..., alias='Rules')


class LifecycleRule(BaseModel):
    AbortIncompleteMultipartUpload_1: Optional[AbortIncompleteMultipartUpload] = Field(
        None, alias='AbortIncompleteMultipartUpload'
    )
    Expiration: Optional[LifecycleExpiration] = None
    Filter: Optional[LifecycleRuleFilter] = None
    ID_1: Optional[ID] = Field(None, alias='ID')
    NoncurrentVersionExpiration_1: Optional[NoncurrentVersionExpiration] = Field(
        None, alias='NoncurrentVersionExpiration'
    )
    NoncurrentVersionTransitions: Optional[NoncurrentVersionTransitionList] = None
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Status: ExpirationStatus
    Transitions: Optional[TransitionList] = None


class LifecycleRules(RootModel[List[LifecycleRule]]):
    root: List[LifecycleRule]


class ListBucketIntelligentTieringConfigurationsOutput(BaseModel):
    ContinuationToken: Optional[Token] = None
    IntelligentTieringConfigurationList_1: Optional[
        IntelligentTieringConfigurationList
    ] = Field(None, alias='IntelligentTieringConfigurationList')
    IsTruncated_1: Optional[IsTruncated] = Field(None, alias='IsTruncated')
    NextContinuationToken: Optional[NextToken] = None


class MetricsConfiguration(BaseModel):
    Filter: Optional[MetricsFilter] = None
    Id: MetricsId


class MetricsConfigurationList(RootModel[List[MetricsConfiguration]]):
    root: List[MetricsConfiguration]


class NotificationConfiguration(BaseModel):
    EventBridgeConfiguration_1: Optional[EventBridgeConfiguration] = Field(
        None, alias='EventBridgeConfiguration'
    )
    LambdaFunctionConfigurations: Optional[LambdaFunctionConfigurationList] = None
    QueueConfigurations: Optional[QueueConfigurationList] = None
    TopicConfigurations: Optional[TopicConfigurationList] = None


class OutputLocation(BaseModel):
    S3: Optional[S3Location] = None


class PutBucketAclRequest(BaseModel):
    AccessControlPolicy_1: Optional[AccessControlPolicy] = Field(
        None, alias='AccessControlPolicy'
    )


class PutBucketIntelligentTieringConfigurationRequest(BaseModel):
    IntelligentTieringConfiguration_1: IntelligentTieringConfiguration = Field(
        ..., alias='IntelligentTieringConfiguration'
    )


class PutBucketLifecycleRequest(BaseModel):
    LifecycleConfiguration_1: Optional[LifecycleConfiguration] = Field(
        None, alias='LifecycleConfiguration'
    )


class PutBucketLoggingRequest(BaseModel):
    BucketLoggingStatus_1: BucketLoggingStatus = Field(..., alias='BucketLoggingStatus')


class PutBucketMetricsConfigurationRequest(BaseModel):
    MetricsConfiguration_1: MetricsConfiguration = Field(
        ..., alias='MetricsConfiguration'
    )


class PutBucketNotificationConfigurationRequest(BaseModel):
    NotificationConfiguration_1: NotificationConfiguration = Field(
        ..., alias='NotificationConfiguration'
    )


class PutObjectAclRequest(BaseModel):
    AccessControlPolicy_1: Optional[AccessControlPolicy] = Field(
        None, alias='AccessControlPolicy'
    )


class ReplicationRule(BaseModel):
    DeleteMarkerReplication_1: Optional[DeleteMarkerReplication] = Field(
        None, alias='DeleteMarkerReplication'
    )
    Destination_1: Destination = Field(..., alias='Destination')
    ExistingObjectReplication_1: Optional[ExistingObjectReplication] = Field(
        None, alias='ExistingObjectReplication'
    )
    Filter: Optional[ReplicationRuleFilter] = None
    ID_1: Optional[ID] = Field(None, alias='ID')
    Prefix_1: Optional[Prefix] = Field(None, alias='Prefix')
    Priority_1: Optional[Priority] = Field(None, alias='Priority')
    SourceSelectionCriteria_1: Optional[SourceSelectionCriteria] = Field(
        None, alias='SourceSelectionCriteria'
    )
    Status: ReplicationRuleStatus


class ReplicationRules(RootModel[List[ReplicationRule]]):
    root: List[ReplicationRule]


class RestoreRequest(BaseModel):
    Days_1: Optional[Days] = Field(None, alias='Days')
    Description_1: Optional[Description] = Field(None, alias='Description')
    GlacierJobParameters_1: Optional[GlacierJobParameters] = Field(
        None, alias='GlacierJobParameters'
    )
    OutputLocation_1: Optional[OutputLocation] = Field(None, alias='OutputLocation')
    SelectParameters_1: Optional[SelectParameters] = Field(
        None, alias='SelectParameters'
    )
    Tier_1: Optional[Tier] = Field(None, alias='Tier')
    Type: Optional[RestoreRequestType] = None


class StorageClassAnalysis(BaseModel):
    DataExport: Optional[StorageClassAnalysisDataExport] = None


class AnalyticsConfiguration1(BaseModel):
    Filter: Optional[AnalyticsFilter] = None
    Id: Optional[AnalyticsId] = None
    StorageClassAnalysis_1: Optional[StorageClassAnalysis] = Field(
        None, alias='StorageClassAnalysis'
    )


class FieldBucketAnalyticsIdPutRequest(BaseModel):
    AnalyticsConfiguration: AnalyticsConfiguration1 = Field(
        ...,
        description='Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.',
    )


class InventoryConfiguration1(BaseModel):
    Destination: Optional[InventoryDestination] = None
    Filter: Optional[InventoryFilter] = None
    Id: Optional[InventoryId] = None
    IncludedObjectVersions: Optional[InventoryIncludedObjectVersions] = None
    IsEnabled_1: Optional[IsEnabled] = Field(None, alias='IsEnabled')
    OptionalFields: Optional[InventoryOptionalFields] = None
    Schedule: Optional[InventorySchedule] = None


class FieldBucketInventoryIdPutRequest(BaseModel):
    InventoryConfiguration: InventoryConfiguration1 = Field(
        ...,
        description='Specifies the inventory configuration for an Amazon S3 bucket. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGETInventoryConfig.html">GET Bucket inventory</a> in the <i>Amazon S3 API Reference</i>. ',
    )


class LifecycleConfiguration1(BaseModel):
    Rules: Optional[LifecycleRules] = None


class FieldBucketLifecyclePutRequest(BaseModel):
    LifecycleConfiguration: Optional[LifecycleConfiguration1] = Field(
        None,
        description='Specifies the lifecycle configuration for objects in an Amazon S3 bucket. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html">Object Lifecycle Management</a> in the <i>Amazon S3 User Guide</i>.',
    )


class FieldBucketNotificationPutRequest(BaseModel):
    NotificationConfiguration_1: NotificationConfiguration = Field(
        ...,
        alias='NotificationConfiguration',
        description='A container for specifying the notification configuration of the bucket. If this element is empty, notifications are turned off for the bucket.',
    )


class ReplicationConfiguration1(BaseModel):
    Role_1: Optional[Role] = Field(None, alias='Role')
    Rules: Optional[ReplicationRules] = None


class FieldBucketReplicationPutRequest(BaseModel):
    ReplicationConfiguration: ReplicationConfiguration1 = Field(
        ...,
        description='A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB.',
    )


class FieldBucketKeyRestorePostRequest(BaseModel):
    RestoreRequest_1: Optional[RestoreRequest] = Field(
        None,
        alias='RestoreRequest',
        description='Container for restore job parameters.',
    )


class AnalyticsConfiguration(BaseModel):
    Filter: Optional[AnalyticsFilter] = None
    Id: AnalyticsId
    StorageClassAnalysis_1: StorageClassAnalysis = Field(
        ..., alias='StorageClassAnalysis'
    )


class AnalyticsConfigurationList(RootModel[List[AnalyticsConfiguration]]):
    root: List[AnalyticsConfiguration]


class BucketLifecycleConfiguration(BaseModel):
    Rules: LifecycleRules


class GetBucketAnalyticsConfigurationOutput(BaseModel):
    AnalyticsConfiguration_1: Optional[AnalyticsConfiguration] = Field(
        None, alias='AnalyticsConfiguration'
    )


class GetBucketIntelligentTieringConfigurationOutput(BaseModel):
    IntelligentTieringConfiguration_1: Optional[IntelligentTieringConfiguration] = (
        Field(None, alias='IntelligentTieringConfiguration')
    )


class GetBucketLifecycleConfigurationOutput(BaseModel):
    Rules: Optional[LifecycleRules] = None


class GetBucketMetricsConfigurationOutput(BaseModel):
    MetricsConfiguration_1: Optional[MetricsConfiguration] = Field(
        None, alias='MetricsConfiguration'
    )


class InventoryConfiguration(BaseModel):
    Destination: InventoryDestination
    Filter: Optional[InventoryFilter] = None
    Id: InventoryId
    IncludedObjectVersions: InventoryIncludedObjectVersions
    IsEnabled_1: IsEnabled = Field(..., alias='IsEnabled')
    OptionalFields: Optional[InventoryOptionalFields] = None
    Schedule: InventorySchedule


class InventoryConfigurationList(RootModel[List[InventoryConfiguration]]):
    root: List[InventoryConfiguration]


class ListBucketAnalyticsConfigurationsOutput(BaseModel):
    AnalyticsConfigurationList_1: Optional[AnalyticsConfigurationList] = Field(
        None, alias='AnalyticsConfigurationList'
    )
    ContinuationToken: Optional[Token] = None
    IsTruncated_1: Optional[IsTruncated] = Field(None, alias='IsTruncated')
    NextContinuationToken: Optional[NextToken] = None


class ListBucketInventoryConfigurationsOutput(BaseModel):
    ContinuationToken: Optional[Token] = None
    InventoryConfigurationList_1: Optional[InventoryConfigurationList] = Field(
        None, alias='InventoryConfigurationList'
    )
    IsTruncated_1: Optional[IsTruncated] = Field(None, alias='IsTruncated')
    NextContinuationToken: Optional[NextToken] = None


class ListBucketMetricsConfigurationsOutput(BaseModel):
    ContinuationToken: Optional[Token] = None
    IsTruncated_1: Optional[IsTruncated] = Field(None, alias='IsTruncated')
    MetricsConfigurationList_1: Optional[MetricsConfigurationList] = Field(
        None, alias='MetricsConfigurationList'
    )
    NextContinuationToken: Optional[NextToken] = None


class PutBucketAnalyticsConfigurationRequest(BaseModel):
    AnalyticsConfiguration_1: AnalyticsConfiguration = Field(
        ..., alias='AnalyticsConfiguration'
    )


class PutBucketInventoryConfigurationRequest(BaseModel):
    InventoryConfiguration_1: InventoryConfiguration = Field(
        ..., alias='InventoryConfiguration'
    )


class PutBucketLifecycleConfigurationRequest(BaseModel):
    LifecycleConfiguration: Optional[BucketLifecycleConfiguration] = None


class ReplicationConfiguration(BaseModel):
    Role_1: Role = Field(..., alias='Role')
    Rules: ReplicationRules


class RestoreObjectRequest(BaseModel):
    RestoreRequest_1: Optional[RestoreRequest] = Field(None, alias='RestoreRequest')


class GetBucketInventoryConfigurationOutput(BaseModel):
    InventoryConfiguration_1: Optional[InventoryConfiguration] = Field(
        None, alias='InventoryConfiguration'
    )


class GetBucketReplicationOutput(BaseModel):
    ReplicationConfiguration_1: Optional[ReplicationConfiguration] = Field(
        None, alias='ReplicationConfiguration'
    )


class PutBucketReplicationRequest(BaseModel):
    ReplicationConfiguration_1: ReplicationConfiguration = Field(
        ..., alias='ReplicationConfiguration'
    )
